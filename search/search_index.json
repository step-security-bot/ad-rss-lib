{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ufeffC++ Library for Responsibility Sensitive Safety Table of contents Introduction License Documentation Releases Release 4.x Release 3.x Release 2.x Release 1.x Getting Started Supported Systems Building the library Contributing Introduction \u00b6 This library intends to provide a C++ implementation of the Responsibility Sensitive Safety model (RSS) for Automated Vehicles. RSS is described in the following paper. Potential users of this C++ library are encouraged to read these papers in order to become familiar with the concepts and functions provided by the library. On a Formal Model of Safe and Scalable Self-driving Cars, S. Shalev-Shwartz, S. Shammah, A. Shashua, Mobileye, arXiv:1708.06374, https://arxiv.org/abs/1708.06374 The RSS module in this library receives (processed) sensor information as input and provides actuator command restrictions as output. The input to the RSS module is an object list, with information about all objects (road agents) in the surrounding environment of the ego vehicle. For each object, the RSS module creates a description of the object-ego vehicle pair and their properties, called a \"situation\". For each situation, the relevant RSS safety checks are performed and a proper response is calculated. Finally, one overall response is obtained by combining the responses calculated for each object-ego vehicle situation. The resulting actuation command restrictions, in the form of longitudinal and lateral limits on acceleration are provided as output. The ad_rss library contains a stand-alone C++ implementation of the RSS module. Conversion of AV sensor data to the input object list required by the RSS module is outside the scope of the ad_rss library. This includes conversion of object location and motion in a Cartesian world coordinate system into a constellation based coordinate system. Conversion of the output proper response and acceleration restrictions to real AV actuation commands (enforcing the restrictions) is outside the scope of this library. This conversion depends strongly on the software and hardware setup of the actual (or simulated) vehicle. The scope, design and architecture of this C++ library for RSS is described in more detail in the following document packaged with this release. This documentation includes guidance on the usage of the RSS library and its integration into a automated driving system. Users of this library are strongly encouraged to read this documentation prior to integration of the library. Integrating RSS with automated driving maps \u00b6 When RSS is to be integrated into a larger system it is usually up to the user implementation to provide the required input into RSS based on the environment information available within the system. The ad_rss_map_integration library provides an example C++ implementation for integrating RSS with automated driving maps. Usage of ad-rss-lib \u00b6 If you use ad-rss-lib for any publication, please cite the IV'2019 paper: @INPROCEEDINGS{ title={Towards Standardization of AV Safety: C++ Library for Responsibility Sensitive Safety} author={Gassmann, Bernd and Oboril, Fabian and Buerkle, Cornelius and Liu, Shuang and Yan, Shoumeng and Elli, Maria Soledad and Alvarez, Ignacio and Aerrabotu, Naveen and Jaber, Suhel and van Beek, Peter and Iyer, Darshan and Weast, Jack} booktitle={2019 IEEE Intelligent Vehicles Symposium (IV)} year={2019} } Usage with Python Starting with Release v1.6, it is possible to use the ad-rss-lib library also with Python. Please see the Documentation on the Python binding for ad_rss or ad_rss_map_integration_python for further information. Usage within CARLA This library can be used together with the open-source driving simulator CARLA to investigate the behavior of RSS. A first version is shown in the following video sequence: Usage within Baidu Apollo In addition, the library is already integrated and used in Baidu's Apollo Open Platform stack : License \u00b6 This software library is provided under the LGPL-2.1 open-source license: https://opensource.org/licenses/LGPL-2.1. In addition, the terms in the following apply: RELEASE NOTES AND DISCLAIMERS . Documentation \u00b6 Visit the project's GitHub page to access the online version of the full documentation of this library. This includes: Doxygen Background documentation . Integrate RSS with AD map data and respective Doxygen . If you have any additional question not answered therein, you might find more in the FAQ Releases \u00b6 General release notes and changes can be found in the Changelog Release 4.x.x These releases extends the 3.x version with handling of unstructured roads and pedestrians. Release 3.x.x These releases improve the 2.x version capabilities on constellation creation. Release 2.x.x These releases extend the 1.x version with map integration for extended usability. Release 1.x.x The initial release of the C++ software library for RSS implements a subset of the rules and calculations specified in the published RSS paper. This means that this release handles a subset of automated driving scenarios, described below. Scenarios other than this subset cannot be handled. Features & Limitations This release implements the RSS calculations and rules corresponding to the following scenarios: Multi-lane roads, i.e. longitudinal and lateral safe distance and proper response determination; and Intersections, i.e. two or more routes of different geometry, rules for intersections of routes, with priority/right of way, and longitudinal and lateral proper response determination. However, in the case of intersections, it is assumed that there is always a lateral conflict; and Unstructured roads and pedestrians. The following parts of RSS are NOT implemented in this release of the library software: Occlusions; Longitudinal or lateral evasive maneuvers as defined by RSS; and Intersections without a lateral conflict. Note: The RSS module in this library does not initiate evasive manuevers. At the same time, it would not hinder an evasive manuever being executed by the AV driving policy and planning modules, as long as it is compliant with the required RSS proper response. Getting started \u00b6 Installation of dependencies Currently, the focused operating systems are Ubuntu 20.04 and Ubuntu 22.04. Nevertheless, the library should work in a similar way for any other Linux OS. To install the basic dependencies for Ubuntu 20.04/22.04 execute the following command: user$> sudo apt-get install git build-essential cmake libboost-dev libpugixml-dev libgtest-dev libpython-dev libproj-dev If you want to use doxygen for API documentation, please also install: user$> sudo apt-get install doxygen graphviz Get the library To download the library, you may run: user$> git clone https://github.com/intel/ad-rss-lib.git user$> cd ad-rss-lib Supported systems Development systems are Ubuntu 20.04 and Ubuntu 22.04 Following compiler and Python combinations are tested continously : Ubuntu 20.04 Ubuntu 22.04 GCC 9 x Clang 10 x GCC 11 x Clang 14 x Python 3.8 x Python 3.10 x x Important: cmake is required to be at least version 3.5! Building the library \u00b6 See the detailed Build instructions . Contributing \u00b6 Contibutions are very welcome! Before submitting a pull request, please ensure that your code compiles successfully and that the tests run successfully. Please also check that your code formatting complies to the provided clang style. To do so, you can run: ad-rss-lib$> sudo apt-get install clang-format-14 ad-rss-lib$> find -iname *.cpp -o -iname *.hpp | xargs clang-format-14 -style=file -i This command will automatically update the code formatting to be compliant with our style. In addition, please perform a static code analysis, if possible. ad-rss-lib$> sudo apt-get install clang-tidy ad-rss-lib$> cmake -DBUILD_STATIC_ANALYSIS=ON ad-rss-lib$> make clang-tidy This may provide a list of possible improvements that you would like to consider in your pull request.","title":"Home"},{"location":"#introduction","text":"This library intends to provide a C++ implementation of the Responsibility Sensitive Safety model (RSS) for Automated Vehicles. RSS is described in the following paper. Potential users of this C++ library are encouraged to read these papers in order to become familiar with the concepts and functions provided by the library. On a Formal Model of Safe and Scalable Self-driving Cars, S. Shalev-Shwartz, S. Shammah, A. Shashua, Mobileye, arXiv:1708.06374, https://arxiv.org/abs/1708.06374 The RSS module in this library receives (processed) sensor information as input and provides actuator command restrictions as output. The input to the RSS module is an object list, with information about all objects (road agents) in the surrounding environment of the ego vehicle. For each object, the RSS module creates a description of the object-ego vehicle pair and their properties, called a \"situation\". For each situation, the relevant RSS safety checks are performed and a proper response is calculated. Finally, one overall response is obtained by combining the responses calculated for each object-ego vehicle situation. The resulting actuation command restrictions, in the form of longitudinal and lateral limits on acceleration are provided as output. The ad_rss library contains a stand-alone C++ implementation of the RSS module. Conversion of AV sensor data to the input object list required by the RSS module is outside the scope of the ad_rss library. This includes conversion of object location and motion in a Cartesian world coordinate system into a constellation based coordinate system. Conversion of the output proper response and acceleration restrictions to real AV actuation commands (enforcing the restrictions) is outside the scope of this library. This conversion depends strongly on the software and hardware setup of the actual (or simulated) vehicle. The scope, design and architecture of this C++ library for RSS is described in more detail in the following document packaged with this release. This documentation includes guidance on the usage of the RSS library and its integration into a automated driving system. Users of this library are strongly encouraged to read this documentation prior to integration of the library.","title":"Introduction "},{"location":"#integrating-rss-with-automated-driving-maps","text":"When RSS is to be integrated into a larger system it is usually up to the user implementation to provide the required input into RSS based on the environment information available within the system. The ad_rss_map_integration library provides an example C++ implementation for integrating RSS with automated driving maps.","title":"Integrating RSS with automated driving maps"},{"location":"#usage-of-ad-rss-lib","text":"If you use ad-rss-lib for any publication, please cite the IV'2019 paper: @INPROCEEDINGS{ title={Towards Standardization of AV Safety: C++ Library for Responsibility Sensitive Safety} author={Gassmann, Bernd and Oboril, Fabian and Buerkle, Cornelius and Liu, Shuang and Yan, Shoumeng and Elli, Maria Soledad and Alvarez, Ignacio and Aerrabotu, Naveen and Jaber, Suhel and van Beek, Peter and Iyer, Darshan and Weast, Jack} booktitle={2019 IEEE Intelligent Vehicles Symposium (IV)} year={2019} }","title":"Usage of ad-rss-lib"},{"location":"#license","text":"This software library is provided under the LGPL-2.1 open-source license: https://opensource.org/licenses/LGPL-2.1. In addition, the terms in the following apply: RELEASE NOTES AND DISCLAIMERS .","title":"License "},{"location":"#documentation","text":"Visit the project's GitHub page to access the online version of the full documentation of this library. This includes: Doxygen Background documentation . Integrate RSS with AD map data and respective Doxygen . If you have any additional question not answered therein, you might find more in the FAQ","title":"Documentation"},{"location":"#releases","text":"General release notes and changes can be found in the Changelog","title":"Releases "},{"location":"#getting-started","text":"","title":"Getting started "},{"location":"#building-the-library","text":"See the detailed Build instructions .","title":"Building the library "},{"location":"#contributing","text":"Contibutions are very welcome! Before submitting a pull request, please ensure that your code compiles successfully and that the tests run successfully. Please also check that your code formatting complies to the provided clang style. To do so, you can run: ad-rss-lib$> sudo apt-get install clang-format-14 ad-rss-lib$> find -iname *.cpp -o -iname *.hpp | xargs clang-format-14 -style=file -i This command will automatically update the code formatting to be compliant with our style. In addition, please perform a static code analysis, if possible. ad-rss-lib$> sudo apt-get install clang-tidy ad-rss-lib$> cmake -DBUILD_STATIC_ANALYSIS=ON ad-rss-lib$> make clang-tidy This may provide a list of possible improvements that you would like to consider in your pull request.","title":"Contributing "},{"location":"BUILDING/","text":"General build instructions Dependencies \u00b6 The components within this repository have some dependencies: ad_rss : ad_physics: https://github.com/carla-simulator/map.git spdlog: https://github.com/gabime/spdlog.git Boost ad_rss_python (if Python binding build enabled): Python lib castxml, pygccxml and py++ ad_rss_map_integration : ad_rss ad_map_access: https://github.com/carla-simulator/map.git - Boost (including components filesystem and program_options) ad_map_opendrive_reader: https://github.com/carla-simulator/map.git pugixml proj: https://www.osgeo.org/projects/proj/ spdlog: https://github.com/gabime/spdlog.git ad_rss_map_integration_python (if Python binding build enabled): ad_map_access_python: https://github.com/carla-simulator/map.git ad_physics_python: https://github.com/carla-simulator/map.git Python lib castxml, pygccxml and py++ all components when enabling unit tests : gtest aka. googletests < 1.10 : https://github.com/google/googletest xmlrunner Dependencies provided by Ubunutu (>= 18.04): Boost pugixml libproj-dev gtest libpython-dev Those can be installed by calling: $> sudo apt-get install libboost-all-dev libpugixml-dev libgtest-dev libpython-dev libproj-dev Additional dependencies for the python bindings: $> sudo apt-get install castxml $> pip install --user pygccxml pyplusplus xmlrunner Remaining dependencies are present as GIT submodules; also to fix the version of these: ad_map_access ad_map_opendrive_reader ad_physics spdlog Building \u00b6 For compiling all libraries and the dependencies, colcon is used colcon . Please use the link above for installation instructions. This repository is prepared as colcon workspace including all dependencies not provided as installable packages by the OS. Those dependencies are part of the dependencies folder as GIT submodules. To properly fetch these, the submodules have to be updated and initialized. ad-rss-lib$> git submodule update --init --recursive Once this is done, the full set of dependencies and components can be built calling: ad-rss-lib$> colcon build All components will be compiled respecting the dependencies between them. The python bindings are disabled by default. To integrate them into the build you can make use of the prepared colcon meta file: ad-rss-lib$> colcon build --metas colcon_python.meta colcon_python.meta enables python build (-DBUILD_PYTHON_BINDING=ON). To specify the python version to be used you call e.g.: ad-rss-lib$> colcon build --metas colcon_python.meta --cmake-args -DPYTHON_BINDING_VERSION=3.8 If cmake isn't able to find the requested python version you can try to specify the python executable explicitly (e.g. under Ubuntu22.04): ad-rss-lib$> colcon build --metas colcon_python.meta --cmake-args -DPYTHON_BINDING_VERSION=3.10 -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.10 Build options \u00b6 There are some CMake options affecting what or how the components are built. BUILD_TESTING: Enables unit tests compilation BUILD_APIDOC: Enables API documentation building BUILD_HARDENING: Enables hardening compiler and linker flags BUILD_PYTHON_BINDING: Enables the build of the respective python bindings PYTHON_BINDING_VERSION: Select the python version to use explicitly e.g. \"3.8\". (Note: If that's not one of the system installed python versions, you have to ensure that the boost-python binding for that python version is available!) By default, all options are set to off. Any of these could be activate by adding them via the colcon call above as \"--cmake-args -D<OPTION>=[ON|OFF]\", e.g.: ad-rss-lib$> colcon build --cmake-args -DBUILD_TESTING=ON -DBUILD_APIDOC=ON -DBUILD_PYTHON_BINDING=ON -DPYTHON_BINDING_VERSION=3.8 Unit tests \u00b6 ad-rss-lib$> colcon build --cmake-args -DBUILD_TESTING=ON When activating the Unit tests, they all can be executed with: ad-rss-lib$> colcon test API documentation \u00b6 When BUILD_APIDOC is enabled, the \"colcon\" call will automatically generate the API documentation. ad-rss-lib$> colcon build --cmake-args -DBUILD_APIDOC=ON The API documentation is written to the apidoc folder within the build directory. Build hardening \u00b6 Usually, build hardening is injected by the surrounding build system. Nevertheless, the CMakeLists.txt defines hardening flags to ensure the code is compatible to respective flags. To enable hardening compiler and linker flags: ad-rss-lib$> colcon build --cmake-args -DBUILD_HARDENING=ON","title":"General build instructions"},{"location":"BUILDING/#dependencies","text":"The components within this repository have some dependencies: ad_rss : ad_physics: https://github.com/carla-simulator/map.git spdlog: https://github.com/gabime/spdlog.git Boost ad_rss_python (if Python binding build enabled): Python lib castxml, pygccxml and py++ ad_rss_map_integration : ad_rss ad_map_access: https://github.com/carla-simulator/map.git - Boost (including components filesystem and program_options) ad_map_opendrive_reader: https://github.com/carla-simulator/map.git pugixml proj: https://www.osgeo.org/projects/proj/ spdlog: https://github.com/gabime/spdlog.git ad_rss_map_integration_python (if Python binding build enabled): ad_map_access_python: https://github.com/carla-simulator/map.git ad_physics_python: https://github.com/carla-simulator/map.git Python lib castxml, pygccxml and py++ all components when enabling unit tests : gtest aka. googletests < 1.10 : https://github.com/google/googletest xmlrunner Dependencies provided by Ubunutu (>= 18.04): Boost pugixml libproj-dev gtest libpython-dev Those can be installed by calling: $> sudo apt-get install libboost-all-dev libpugixml-dev libgtest-dev libpython-dev libproj-dev Additional dependencies for the python bindings: $> sudo apt-get install castxml $> pip install --user pygccxml pyplusplus xmlrunner Remaining dependencies are present as GIT submodules; also to fix the version of these: ad_map_access ad_map_opendrive_reader ad_physics spdlog","title":"Dependencies"},{"location":"BUILDING/#building","text":"For compiling all libraries and the dependencies, colcon is used colcon . Please use the link above for installation instructions. This repository is prepared as colcon workspace including all dependencies not provided as installable packages by the OS. Those dependencies are part of the dependencies folder as GIT submodules. To properly fetch these, the submodules have to be updated and initialized. ad-rss-lib$> git submodule update --init --recursive Once this is done, the full set of dependencies and components can be built calling: ad-rss-lib$> colcon build All components will be compiled respecting the dependencies between them. The python bindings are disabled by default. To integrate them into the build you can make use of the prepared colcon meta file: ad-rss-lib$> colcon build --metas colcon_python.meta colcon_python.meta enables python build (-DBUILD_PYTHON_BINDING=ON). To specify the python version to be used you call e.g.: ad-rss-lib$> colcon build --metas colcon_python.meta --cmake-args -DPYTHON_BINDING_VERSION=3.8 If cmake isn't able to find the requested python version you can try to specify the python executable explicitly (e.g. under Ubuntu22.04): ad-rss-lib$> colcon build --metas colcon_python.meta --cmake-args -DPYTHON_BINDING_VERSION=3.10 -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.10","title":"Building"},{"location":"BUILDING/#build-options","text":"There are some CMake options affecting what or how the components are built. BUILD_TESTING: Enables unit tests compilation BUILD_APIDOC: Enables API documentation building BUILD_HARDENING: Enables hardening compiler and linker flags BUILD_PYTHON_BINDING: Enables the build of the respective python bindings PYTHON_BINDING_VERSION: Select the python version to use explicitly e.g. \"3.8\". (Note: If that's not one of the system installed python versions, you have to ensure that the boost-python binding for that python version is available!) By default, all options are set to off. Any of these could be activate by adding them via the colcon call above as \"--cmake-args -D<OPTION>=[ON|OFF]\", e.g.: ad-rss-lib$> colcon build --cmake-args -DBUILD_TESTING=ON -DBUILD_APIDOC=ON -DBUILD_PYTHON_BINDING=ON -DPYTHON_BINDING_VERSION=3.8","title":"Build options"},{"location":"BUILDING/#unit-tests","text":"ad-rss-lib$> colcon build --cmake-args -DBUILD_TESTING=ON When activating the Unit tests, they all can be executed with: ad-rss-lib$> colcon test","title":"Unit tests"},{"location":"BUILDING/#api-documentation","text":"When BUILD_APIDOC is enabled, the \"colcon\" call will automatically generate the API documentation. ad-rss-lib$> colcon build --cmake-args -DBUILD_APIDOC=ON The API documentation is written to the apidoc folder within the build directory.","title":"API documentation"},{"location":"BUILDING/#build-hardening","text":"Usually, build hardening is injected by the surrounding build system. Nevertheless, the CMakeLists.txt defines hardening flags to ensure the code is compatible to respective flags. To enable hardening compiler and linker flags: ad-rss-lib$> colcon build --cmake-args -DBUILD_HARDENING=ON","title":"Build hardening"},{"location":"CHANGELOG/","text":"Latest changes \u00b6 Maintenance Improve security of github actions Disable Ubuntu 18.04 builds Release 4.5.3 \u00b6 Maintenance Enable Ubuntu 22.04 builds Update map to v2.6.3 Release 4.5.2 \u00b6 Maintenance Update map to v2.6.2 Release 4.5.1 \u00b6 Maintenance Fix: removed duplicated spdlog dependency Update map to v2.6.0 Release 4.5.0 \u00b6 New Features Remove Ubuntu 16.04 support Add creation of python wheels Update map to v2.5.0 Release 4.4.3 \u00b6 Maintenance Fix: ad_rss_map_integration python binding build Release 4.4.2 \u00b6 Maintenance Ease version number handling and folder layout Update map to latest v2.4.5_hotfix commit Release 4.4.1 \u00b6 Maintenance Fix: Consider lateral fluctuation margin correctly. Fix: ad_rss_map_integration don't shorten route too much within intersections Updated ad_map_access to v2.4.5 Use target python version for build Fix: Ensure maxSpeedOnAcceleration only limits the actual acceleration while reponse time. python_wrapper_helper.py is now generated by cmake so that it uses the proper C++ standard. Release 4.4.0 \u00b6 Maintenance Unstructured constellation polygon creation: Add several parameters to adjust polygon calculation. Fix issues, refactor code. Release 4.3.0 \u00b6 Maintenance Unstructured constellation polygon creation: Fix vehicle curvature calculation after response time, make DebugDrawing accessible from python Release 4.2.0 \u00b6 Maintenance Improved user interface of python binding Updated ad_map_access to v2.3.0 Update unstructured trajectory set calculation for pedestrians Suppressed python code generation build output Release 4.1.0 \u00b6 Maintenance Update unstructured trajectory set calculation Build documentation update to make the plain cmake build more robust and especially make repeated builds with -DBUILD_PYTHON_BINDING=ON working Release 4.0.1 \u00b6 Maintenance Fixed drive away mode in unstructured scenes Fixed version number of ad_rss_map_integration Release 4.0.0 \u00b6 New Features Support of unstructured scenes/pedestrians Extended ad::rss::situation::SituationType by Unstructured value Extended ad::rss::situation::VehicleState by ad::rss::world::ObjectType and ad::rss::world::ObjectState members Extended ad::rss::state::ProperResponse by ad::rss::state::UnstructuredSceneResponse and ad::rss::state::HeadingRangeVector members Renamed ad::rss::world::AccelerationRestriction -> ad::rss::state::AccelerationRestriction and integrated it as a member into the ad::rss::state::ProperResponse . Reflected this merge of the data types by renaming ad::rss::core::RssCheck::calculateAccelerationRestriction() to ad::rss::core::RssCheck::calculateProperResponse() and adapting the function parameters accordingly. Same applies for ad::rss::core::RssResponseResolving::provideProperResponse() . Extended ad::rss::state::RssState by ad::rss::situation::SituationType and ad::rss::state::UnstructuredSceneRssState members. Extended ad::rss::state::RssStateSnapshot by ad::rss::state::UnstructuredSceneStateInformation member Extended ad::rss::world::ObjectType by Pedestrian value Extended ad::rss::world::Object by ::ad::rss::world::ObjectState member Extended ad::rss::world::RssDynamics by ad::rss::world::UnstructuredSettings member Extended ad::rss::map::RssSceneCreation::appendScenes() parameters by ad::physics::AngularVelocity of ego and object and provide the mode of operation ad::rss::map::RssMode (NotRelevant, Structured, Unstructured) Extended ad::rss::map::RssSceneCreator and ad::rss::map::RssObjectConversion classes to support unstructured scenes Maintenance Harmonized physics calcualions Removed ad::rss::situation::CoordinateSystemAxis type Refactored and extended calculations within Physics.hpp for unstructured cases Made RssFormular.hpp public Fixed consideration of maximum speed on accelerating: Renamed ad::rss::world::RssDynamics::maxSpeed member to maxSpeedOnAcceleration to clarify that it's not the general max speed of the vehicle, but the maximum speed to be considered while accelerating within the response time. Fixed the calcualtions to consider the case that the current speed before the acceleration can already be higher than the maxSpeedOnAcceleration parameter and in this case just no acceleration takes place Improved BUILDING documentation Release 3.0.1 \u00b6 Maintenance Fixed python binding for multiple python version built Added python interface test execution Updated documentation Fixed clang-8 and gcc-9 build Release 3.0.0 \u00b6 New Features In preparation of the integration of unstructured scenes: Deceleration values are given as negative values from now on Remove separate Response Transformation to ease the merge of situations On LateralResponse::None , the minimum value is not brakeMin anymore (that value was in each case irrelevant) Reworked scene creation Made RssSceneCreation a class with supporting classes RssObjectConversion and RssSceneCreator to support multi-threaded scene appending. Allow for scene specific ego vehicle RSS dynamics Handle empty ego route correctly Handle use-case: ego vehicle at back Handle use-case: merging route Restricting routes to relevant scene region to prevent from inaccourate relative distances Ensure that NotRelevantScene also provides filled occupied region content Workaround for route start within intersections: Use objectRoute intersection in intersection scenes if ego route predictions don't provide intersection data at all (to be solved finally within ad::map::intersection::Intersection() class) Massively extended scene creation unit tests Make use of ad::map::route::getENUHeadingOfRoute() for more accurate object heading on route calculation Renamed Math -> Physics and made header public Maintenance Adaptions for python binding built to support newer boost versions as well as multiple python versions at the same time Release 2.0.0 \u00b6 New Features Added Integrating RSS with automated driving maps (ad_rss_map_integration) Added logging support with spdlog Introduced maxSpeed to RssDynamics and RSS calculations to support speed limits for details see world::Velocity supports speed range input to be able to cope with speed fluctuations (i.e. in curves) Maintenance Refactored types and namespaces renamed ad_rss::physics::TimeIndex -> ad::world::TimeIndex renamed ad_rss::physics::CoordinateSystemAxis -> ad::situation::CoordinateSystemAxis renamed ad_rss::physics -> ad::physics and replaced by separate library (ad_physics) to ensure map and rss are using the same base types renamed ad_rss -> ad::rss Renamed actual shared library ad-rss-lib -> ad_rss Refactored folder layout Introduced colcon build for details see Fix unit tests for gcc 7.4.0 (shipped with ubuntu 18.04) Added ObjectIDVector support to Python binding Release 1.6.0 \u00b6 New Features Added Python binding Release 1.5.0 \u00b6 Maintenance License change to LGPL v2.1 Release 1.4.0 \u00b6 Introduced more straight forward interface on intermediate functions to support better integration of the single calls into an external framework: SituationSnapshot, RssStateSnapshot, ProperResponse. Moved the timeIndex from the individual elements into these high level types to support the propagation of the timeIndex even if there are no other vehicles in the surrounding. Did some renaming (e.g. ResponseState->RssState, ResponseStateVector->RssStateVector, ResponseInformation->RssStateInformation, ResponseEvaluator->RssStateEvaluator) to clarify by naming that the individual calcuated states only consider a snapshot in time without analysis of the dangerous threshold. The ProperResponse became its own type and got an own overall isSafe flag and a list of dangerousObjects. Added ObjectId to Situation and RssState to preserve the mapping to the originating object which was lost with the introduction of multiple situations per object. Increase amount of allowed situations because with multiple situations per object the amount of 100 might be hit too fast. Improved merge of input scenarios to facilitate scene variations of the same situation RssIntersectionChecker: since new situations may pop up when e.g. a previously occluded object is entering the field of view, one cannot guarantee that a previous safe state can be found. In this case, we have to brake instead of returning false. Made some RssState operations available via public interface Add option to select library build type (static/dynamic) Release 1.3.0 \u00b6 Allow multiple situations per ego vehicle/object pair: Add RssSituationIdProvider and made RssSituationExtraction a class holding RssSituationIdProvider instance to keep track of the different situation classes Renamed world::Dynamics in world::RssDynamics , extended it by responseTime and separated it from world::Object ; world::Scene got the objectRssDynamics and world::WorldModel the egoVehicleRssDynamics each as separate elements Extended world::Scene by egoVehicle object description as occupied regions and velocity are actually scene dependent (e.g. when considering different vehicle predictions) Added world::ObjectType::Invalid Small updates to be compliant to clang-tidy-3.8 static code analysis Added basic FAQ Added official support for Ubuntu 14.04 (GCC 4.8, Clang 3.4 and 3.8/3.9) Added official support for Ubuntu 18.04 (GCC 7.3) Download/Build gtest on the fly rather than using the version from the OS Fixed documentation of RoadArea LaneSegment ordering (left -> right) Fixed isSafe flags of the resolved response Renamed some internal files from 'RSS...' -> 'Rss...' to have camel-case everywhere Added ResponseInformation to provide more insight into intermediate result calculation Release 1.2.0 \u00b6 Added support for Clang 5 and Clang 6 Added checks to enforce increasing time indices Consider timeIndex=0 as error Reduced maximum vector input sizes to more feasible numbers (20 lane segments, 50 road segments, 100 scenes) Release 1.1.0 \u00b6 Made generated files and tests more explicit by moving into respective folders Extended documentation Increase test coverage Fixed calculateLateralDimensions() Extended extractSituation() by timeIndex parameter Support for GCC 4.8 Harmonized library and git repo name by renaming ad_rss_lib -> ad-rss-lib Release 1.0.0 \u00b6 Initial release","title":"Changelog"},{"location":"CHANGELOG/#latest-changes","text":"","title":"Latest changes"},{"location":"CHANGELOG/#release-453","text":"","title":"Release 4.5.3"},{"location":"CHANGELOG/#release-452","text":"","title":"Release 4.5.2"},{"location":"CHANGELOG/#release-451","text":"","title":"Release 4.5.1"},{"location":"CHANGELOG/#release-450","text":"","title":"Release 4.5.0"},{"location":"CHANGELOG/#release-443","text":"","title":"Release 4.4.3"},{"location":"CHANGELOG/#release-442","text":"","title":"Release 4.4.2"},{"location":"CHANGELOG/#release-441","text":"","title":"Release 4.4.1"},{"location":"CHANGELOG/#release-440","text":"","title":"Release 4.4.0"},{"location":"CHANGELOG/#release-430","text":"","title":"Release 4.3.0"},{"location":"CHANGELOG/#release-420","text":"","title":"Release 4.2.0"},{"location":"CHANGELOG/#release-410","text":"","title":"Release 4.1.0"},{"location":"CHANGELOG/#release-401","text":"","title":"Release 4.0.1"},{"location":"CHANGELOG/#release-400","text":"","title":"Release 4.0.0"},{"location":"CHANGELOG/#release-301","text":"","title":"Release 3.0.1"},{"location":"CHANGELOG/#release-300","text":"","title":"Release 3.0.0"},{"location":"CHANGELOG/#release-200","text":"","title":"Release 2.0.0"},{"location":"CHANGELOG/#release-160","text":"","title":"Release 1.6.0"},{"location":"CHANGELOG/#release-150","text":"","title":"Release 1.5.0"},{"location":"CHANGELOG/#release-140","text":"Introduced more straight forward interface on intermediate functions to support better integration of the single calls into an external framework: SituationSnapshot, RssStateSnapshot, ProperResponse. Moved the timeIndex from the individual elements into these high level types to support the propagation of the timeIndex even if there are no other vehicles in the surrounding. Did some renaming (e.g. ResponseState->RssState, ResponseStateVector->RssStateVector, ResponseInformation->RssStateInformation, ResponseEvaluator->RssStateEvaluator) to clarify by naming that the individual calcuated states only consider a snapshot in time without analysis of the dangerous threshold. The ProperResponse became its own type and got an own overall isSafe flag and a list of dangerousObjects. Added ObjectId to Situation and RssState to preserve the mapping to the originating object which was lost with the introduction of multiple situations per object. Increase amount of allowed situations because with multiple situations per object the amount of 100 might be hit too fast. Improved merge of input scenarios to facilitate scene variations of the same situation RssIntersectionChecker: since new situations may pop up when e.g. a previously occluded object is entering the field of view, one cannot guarantee that a previous safe state can be found. In this case, we have to brake instead of returning false. Made some RssState operations available via public interface Add option to select library build type (static/dynamic)","title":"Release 1.4.0"},{"location":"CHANGELOG/#release-130","text":"Allow multiple situations per ego vehicle/object pair: Add RssSituationIdProvider and made RssSituationExtraction a class holding RssSituationIdProvider instance to keep track of the different situation classes Renamed world::Dynamics in world::RssDynamics , extended it by responseTime and separated it from world::Object ; world::Scene got the objectRssDynamics and world::WorldModel the egoVehicleRssDynamics each as separate elements Extended world::Scene by egoVehicle object description as occupied regions and velocity are actually scene dependent (e.g. when considering different vehicle predictions) Added world::ObjectType::Invalid Small updates to be compliant to clang-tidy-3.8 static code analysis Added basic FAQ Added official support for Ubuntu 14.04 (GCC 4.8, Clang 3.4 and 3.8/3.9) Added official support for Ubuntu 18.04 (GCC 7.3) Download/Build gtest on the fly rather than using the version from the OS Fixed documentation of RoadArea LaneSegment ordering (left -> right) Fixed isSafe flags of the resolved response Renamed some internal files from 'RSS...' -> 'Rss...' to have camel-case everywhere Added ResponseInformation to provide more insight into intermediate result calculation","title":"Release 1.3.0"},{"location":"CHANGELOG/#release-120","text":"Added support for Clang 5 and Clang 6 Added checks to enforce increasing time indices Consider timeIndex=0 as error Reduced maximum vector input sizes to more feasible numbers (20 lane segments, 50 road segments, 100 scenes)","title":"Release 1.2.0"},{"location":"CHANGELOG/#release-110","text":"Made generated files and tests more explicit by moving into respective folders Extended documentation Increase test coverage Fixed calculateLateralDimensions() Extended extractSituation() by timeIndex parameter Support for GCC 4.8 Harmonized library and git repo name by renaming ad_rss_lib -> ad-rss-lib","title":"Release 1.1.0"},{"location":"CHANGELOG/#release-100","text":"Initial release","title":"Release 1.0.0"},{"location":"FAQ/","text":"FAQ Integrating ad-rss-lib into a system \u00b6 This section tries to give answers to the questions that came up while people were integrating ad-rss-lib into their systems. Integration examples \u00b6 The ad-rss-lib is already integrated in other open source projects: Apollo Open Platform : In Apollo Open Automated Driving stack RSS is integrated directly into the planning module to provide additional information to be deployed while planning. CARLA Driving Simulator : In CARLA Open-source simulator for autonomous driving research RSS is integrated as Checker in form of a virtual RssSensor and as a simple (optional) Doer in form of a RssRestrictor . Classes: RssCheck, RssSituationChecking and RssResponseResolving \u00b6 How can I perform the checks? The ad-rss-lib provides more or less two ways of integrating the functionality into a system. The ad::rss::core::RssCheck class performs all required steps one after another. Create a permanent object instance of this class and call calculateAccelerationRestriction() for every step in time continuously. You have to provide the world model data as input and get the acceleration restrictions to be applied as output. If you are interested in the intermediate results you can to call the overloaded version of calculateAccelerationRestriction() or call the processing chain step by step. For this, you have to create permanent object instances of RssSituationExtraction, RssSituationChecking and RssResponseResolving classes and call the following processing chain for every step in time continuously: ad::rss::core::RssSituationExtraction::extractSituations(worldModel, situationVector) ad::rss::core::SituationChecking::checkSituations(situationVector, responseStateVector) ad::rss::core::ResponseResolving::provideProperResponse(responseStateVector, properResponse, accelerationRestriction) Regardless which solution you prefer, you always have to respect the return value of the functions, before you further make use of the information! Why are the functions realized within classes? The observed situations are analyzed by RSS over time. Therefore, the processing steps have to store the state of previous time steps. As a consequence, the object instances of the classes have to exist over time and must not be deleted! Input: world model data \u00b6 The worldModel is the input to the RSS calculations. It is derived from the Sense Subsystem . How do I get to the information required for the input worldModel ? The world model data heavily depends on the system the ad-rss-lib is going to be integrated. Therefore, there is no single answer to this question. Simple scenarios can be derived using basic object data, integration of RSS to the full extend demand more sophisticated a-priori information, usually provided by means of an AD-Map . The unit tests provided with the ad-rss-lib build some basic worldModel structures that might be taken as a starting point. Better examples can be found in the section on Integration examples . Output: rssAccelerationRestrictions \u00b6 The rssAccelerationRestrictions is the output of the RSS calculations. It is given as input of the Act Subsystem . If a RSS restricted acceleration is applied on the actuators, does it mean that RSS is not only a checker? Yes, indeed. At one hand side RSS performs an analysis of the situation over time which detects if a situation is becoming dangerous. In addition, RSS derives also a proper response for the ego-vehicle on how to get out of such. If finally the resulting acceleration restrictions in longitudinal, lateral left and right directions are considered by the actuation system, the situation will become safe again. Is there any impact on the Plan Subsystem ? Should it be adapted since it undergoes RSS acceleration restrictions? There are many possibilities on how the information on the RSS situation analysis can be deployed within a system. It can be used as a plain safety checking and enforcing entity being totally independent from the Plan Subsystem . Then, the Plan Subsystem will only indirectly be influenced in a way, that the vehicle is not following the planing output. But for sure the planning algorithms might directly benefit when feeding back the information from RSS . Even beyond, if the planning algorithms evaluate different driving strategies, RSS can be applied directly within the planning algorithm to influence the rating. This includes also learning algorithms of AI-based planning approaches.","title":"FAQ"},{"location":"FAQ/#integrating-ad-rss-lib-into-a-system","text":"This section tries to give answers to the questions that came up while people were integrating ad-rss-lib into their systems.","title":"Integrating ad-rss-lib into a system"},{"location":"FAQ/#integration-examples","text":"The ad-rss-lib is already integrated in other open source projects: Apollo Open Platform : In Apollo Open Automated Driving stack RSS is integrated directly into the planning module to provide additional information to be deployed while planning. CARLA Driving Simulator : In CARLA Open-source simulator for autonomous driving research RSS is integrated as Checker in form of a virtual RssSensor and as a simple (optional) Doer in form of a RssRestrictor .","title":"Integration examples"},{"location":"FAQ/#classes-rsscheck-rsssituationchecking-and-rssresponseresolving","text":"","title":"Classes: RssCheck, RssSituationChecking and RssResponseResolving"},{"location":"FAQ/#input-world-model-data","text":"The worldModel is the input to the RSS calculations. It is derived from the Sense Subsystem .","title":"Input: world model data"},{"location":"FAQ/#output-rssaccelerationrestrictions","text":"The rssAccelerationRestrictions is the output of the RSS calculations. It is given as input of the Act Subsystem .","title":"Output: rssAccelerationRestrictions"},{"location":"RELEASE_NOTES_AND_DISCLAIMERS/","text":"RELEASE NOTES AND DISCLAIMERS The following additional terms apply to the C++ Library for RSS (the \u201cSoftware\u201d) provided by Intel Corporation (\u201cIntel\u201d) to the recipient (\u201cRecipient\u201d). The Software implements the RSS calculations and rules corresponding to the following scenarios: Multi-lane roads, i.e. longitudinal and lateral safe distance and proper response determination; and Intersections, i.e. two or more routes of different geometry, rules for intersections of routes, with priority/right of way, and longitudinal and lateral proper response determination. However, in the case of intersections, it is assumed that there is always a lateral conflict; and Unstructured roads and pedestrians. The following parts of RSS are NOT implemented in this release of the Software: Occlusions; Longitudinal or lateral evasive maneuvers as defined by RSS; and Intersections without a lateral conflict. Recipient understands, acknowledges and agrees that the Software: is a pre-production, research version intended for use in a testing simulator; should not be considered full, complete, or fully functional; does not contain all features necessary for a production version of the Software; has not been fully tested (including security testing) and may contain bugs, errors or faults; is not suitable for commercial or production release as part of a larger system in its current state; may not be suitable for development of transportation testing applications for test tracks or public roads; and has not obtained any regulatory approvals (such as, UL or FCC), or obtained any certifications or qualifications (such as, AEC-Q100) and may therefore not be certified for use in certain countries or environments. By using the Software, Recipient agrees to the following: Recipient expressly assumes all risks associated with the use of the Software, which are provided \u201c AS IS \u201d by Intel with all faults.","title":"Release Notes and Disclaimer"},{"location":"ad_rss/Appendix-ParameterDiscussion/","text":"Parameter Discussion \u00b6 The RSS papers uses a few constants required for the safety calculations. The values for these constants are not yet defined and open for discussion/regulation. Nevertheless, the implementation of the ad-rss-lib needs to define initial values for these functions. Note To be as flexible as possible, the parameters are implemented as configuration values so these can be easily adjusted during evaluation or after the release. In other words, the values are not hard coded in the library, but can be changed via the provided inputs. In the following, the key parameters and the decision for possible initial values are discussed. The used parameters based on the RSS paper are: Response time \\rho \\rho It is assumed that an AV vehicle has a shorter response time than a human driver. Therefore, there is a need to have two different parameters. As it might not be possible to determine whether another object is an AV vehicle or has a human driver, the ad-rss-lib will safely assume that all other objects are driven by humans. Hence, two parameters for the response time are used: \\rho_{ego} \\rho_{ego} : for the ego vehicle \\rho_{other} \\rho_{other} : for all other objects Acceleration \\alpha \\alpha RSS proposes several different acceleration/deceleration values. One could argue that acceleration/deceleration differs with the type of vehicle. Also at least the acceleration is dependent on the current vehicle speed. As it cannot be assured that the individual acceleration of each and every car can be known and the specific car can be reliably detected, the ad-rss-lib will assume fixed constants for those values. These could be either the maximum physically possible values or restrictions that are imposed by regulation. Also there will not be different values for the ego vehicle and the other vehicles. It could be argued that for the ego vehicle e.g. desired acceleration might be known. Therefore, a shorter safety distance would be sufficient. But as all other vehicles do not know about the intention of the ego vehicle this would lead to a violation of their safe space. So the ad-rss-lib will need to calculate its checks with the globally defined accelerations values even if the vehicle does not intend to utilize them to its limits. The parameters used for acceleration are: \\alpha_{accel,max} \\alpha_{accel,max} maximum possible acceleration \\alpha_{brake,min} \\alpha_{brake,min} minimum allowed braking deceleration in longitudinal direction for most scenarios \\alpha_{brake,max} \\alpha_{brake,max} maximum allowed deceleration in longitudinal direction \\alpha_{brake,min,correct} \\alpha_{brake,min,correct} minimum allowed deceleration in longitudinal direction for a car on its lane with another car approaching on the same lane in wrong driving direction \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} minimum allowed braking deceleration in lateral direction \\alpha^{lat}_{accel,max} \\alpha^{lat}_{accel,max} maximum allowed acceleration in lateral direction \\delta^{lat}_{min} \\delta^{lat}_{min} fluctuation margin for that needs to be respected when calculating lateral safe distance Decision on Selected Parameter Values \u00b6 Note The following parameter values are only suggestions and open for discussion. These can be changed at anytime, if it is required. Response time For the response times a common sense value for human drivers is about 2 seconds. For an AV vehicle the response time could be way lower. In order to be not too restrictive the initial value for the ego vehicle response time will be assumed as 1 second. Hence, \\rho_{other} = 2s \\rho_{other} = 2s and \\rho_{ego} = 1s \\rho_{ego} = 1s . If we assume a case of AD vehicles only, the response time may be reduced. Longitudinal Acceleration Finding meaningful acceleration values is more complicated. At the one hand the values should be as close as possible or even exceed the maximum physically possible values. The minimum deceleration values must also not exceed normal human driving behavior. So assuming a too high deceleration for other cars may lead to a false interpretation of the situation. On the other hand a too big difference between the minimum and maximum acceleration values will lead to a very defensive driving style. As a result, participating in dense traffic, will not be possible (see figure below). A rule of thumb for deceleration in German driving schools is: \\alpha_{brake,min} = 4m/s^2 \\alpha_{brake,min} = 4m/s^2 and \\alpha_{brake,max} = 8m/s^2 \\alpha_{brake,max} = 8m/s^2 . But on the other hand, modern cars are able to decelerate with up to 12m/s^2 12m/s^2 . Especially for deceleration, it is questionable whether it is possible and tolerable to restrict maximum braking below physically possible braking force. For the maximum acceleration at low speeds a standard car will be in the range of 3.4m/s^2 3.4m/s^2 to 7m/s^2 7m/s^2 . But there are also sport cars that can go faster than that. But for acceleration a regulation to a maximum value seems to be more likely than for deceleration. Restricting velocity to the current speed limit Required safety distance for cars driving at 50 km/h (city speed) in same direction with \\alpha_{brake,min} = 4m/s^2 \\alpha_{brake,min} = 4m/s^2 and \\alpha_{brake,max} = 8m/s^2 \\alpha_{brake,max} = 8m/s^2 and \\rho_{ego} = \\rho_{other} = 2s \\rho_{ego} = \\rho_{other} = 2s The assumption that a car can always accelerate at \\alpha_{accel,max} \\alpha_{accel,max} during the reponse time, leads to a significant increase of the required safety distance. The figure above shows the required safety distance for different acceleration values. So acceleration about 4m/s^2 4m/s^2 doubles the required safety distance from 40m 40m to about 80m 80m at city speeds. Therefore, it might be advisable to add a restriction that a car is only allowed to accelerate up to the allowed speed limit. In addition, the common behavior (in Germany) is to respect a safety distance of speed/2, e.g. in a city with a speed limit of 50km/h 50km/h the safety distance shall be 25m 25m . Hence, it is obvious that the parameters may require some adjustments to allow reasonable driving. Further possible restrictions Another possibility to decrease the required safety distance to the leading vehicle would be to take the intention of the ego vehicle into account. E.g. if the ego vehicle is following another vehicle and is not intending to accelerate, then there is no need to assume that the ego vehicle is accelerating during its response time. Nevertheless, there are several issues with that approach: It needs to be assured that all intended and unintended accelerations (e.g. driving down a slope) are known to RSS. If RSS formulas are regarded as regulations, the safety distance must be kept regardless to the intent of the vehicle. Therefore, in the current implementation this approach will not be applied. Lateral Acceleration When defining the parameters for lateral acceleration and deceleration, it is import to keep in mind that the definition must allow bypassing of vehicles. Physically high lateral accelerations are possible. In order to be able to bypass a vehicle that is driving on a parallel lane, the safe lateral distance needs to be safe during the complete response time of the other vehicle. Let us consider two identical vehicles driving on the centerline of two adjacent lanes with zero lateral velocity. There is no lateral conflict, if the distance between the border of the car and the adjacent lane is bigger than the distance that the vehicle will cover when accelerating laterally at maximum during its response time and then decelerating to zero lateral velocity. Distance a vehicle will cover when applying the \"Stated Braking Pattern\" with \\rho_{vehicle} = 2s \\rho_{vehicle} = 2s The figure above shows the required safety distance, without considering the fluctuation margin, each car needs to keep to the lane border so the vehicles can pass without lateral conflict. With an assumed minimal lane width of 3 meters and an assumed vehicle width of 2 meters, the distance from vehicle edge to lane border is 0.5 meter, if the car is driving exactly in the middle of the lane. Hence, the required safety distance must be at most 0.5 meter. When using the same values for acceleration and deceleration this will lead to \\alpha^{lat}_{accel,max} < 0.1m/s^2 \\alpha^{lat}_{accel,max} < 0.1m/s^2 . But when restricting the acceleration to that value a lane change will take almost 8 seconds. As a result it is advisable, to use a higher deceleration than acceleration to keep the required safety margin and allow for faster lane changes. E.g. \\alpha^{lat}_{brake,min} = 0.8m/s^2 \\alpha^{lat}_{brake,min} = 0.8m/s^2 and \\alpha^{lat}_{accel,max} = 0.2m/s^2 \\alpha^{lat}_{accel,max} = 0.2m/s^2 will fulfill the given safety distance requirement. An increase to higher acceleration values is for the given constraints not possible, as the distance covered during response time is already 0.4 meters. It is obvious that given the lateral safety definition a lane change will at least have a duration of two times the response time. The lateral distance requirement is very strict, therefore it is required to also come up with a desirably small value for the required lateral safety margin \\delta^{lat}_{min} \\delta^{lat}_{min} . As this should only cover for fluctuations, there is also no need for a huge margin. Thus initially this value will be set to \\delta^{lat}_{min} = 10 cm \\delta^{lat}_{min} = 10 cm . This value should be able to cover small fluctuations, but will not have a big impact on the safety distance. Note As a conservative starting point the values can be set to: Parameter Value \\rho_{ego} \\rho_{ego} 1s 1s \\rho_{other} \\rho_{other} 2s 2s \\alpha_{accel,max} \\alpha_{accel,max} 3.5m/s^2 3.5m/s^2 \\alpha_{brake,min} \\alpha_{brake,min} 4m/s^2 4m/s^2 \\alpha_{brake,max} \\alpha_{brake,max} 8m/s^2 8m/s^2 \\alpha_{brake,min,correct} \\alpha_{brake,min,correct} 3m/s^2 3m/s^2 \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} 0.8m/s^2 0.8m/s^2 \\alpha^{lat}_{accel,max} \\alpha^{lat}_{accel,max} 0.2m/s^2 0.2m/s^2 \\delta^{lat}_{min} \\delta^{lat}_{min} 10cm 10cm","title":"Parameter Discussion"},{"location":"ad_rss/Appendix-ParameterDiscussion/#parameter-discussion","text":"The RSS papers uses a few constants required for the safety calculations. The values for these constants are not yet defined and open for discussion/regulation. Nevertheless, the implementation of the ad-rss-lib needs to define initial values for these functions. Note To be as flexible as possible, the parameters are implemented as configuration values so these can be easily adjusted during evaluation or after the release. In other words, the values are not hard coded in the library, but can be changed via the provided inputs. In the following, the key parameters and the decision for possible initial values are discussed. The used parameters based on the RSS paper are: Response time \\rho \\rho It is assumed that an AV vehicle has a shorter response time than a human driver. Therefore, there is a need to have two different parameters. As it might not be possible to determine whether another object is an AV vehicle or has a human driver, the ad-rss-lib will safely assume that all other objects are driven by humans. Hence, two parameters for the response time are used: \\rho_{ego} \\rho_{ego} : for the ego vehicle \\rho_{other} \\rho_{other} : for all other objects Acceleration \\alpha \\alpha RSS proposes several different acceleration/deceleration values. One could argue that acceleration/deceleration differs with the type of vehicle. Also at least the acceleration is dependent on the current vehicle speed. As it cannot be assured that the individual acceleration of each and every car can be known and the specific car can be reliably detected, the ad-rss-lib will assume fixed constants for those values. These could be either the maximum physically possible values or restrictions that are imposed by regulation. Also there will not be different values for the ego vehicle and the other vehicles. It could be argued that for the ego vehicle e.g. desired acceleration might be known. Therefore, a shorter safety distance would be sufficient. But as all other vehicles do not know about the intention of the ego vehicle this would lead to a violation of their safe space. So the ad-rss-lib will need to calculate its checks with the globally defined accelerations values even if the vehicle does not intend to utilize them to its limits. The parameters used for acceleration are: \\alpha_{accel,max} \\alpha_{accel,max} maximum possible acceleration \\alpha_{brake,min} \\alpha_{brake,min} minimum allowed braking deceleration in longitudinal direction for most scenarios \\alpha_{brake,max} \\alpha_{brake,max} maximum allowed deceleration in longitudinal direction \\alpha_{brake,min,correct} \\alpha_{brake,min,correct} minimum allowed deceleration in longitudinal direction for a car on its lane with another car approaching on the same lane in wrong driving direction \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} minimum allowed braking deceleration in lateral direction \\alpha^{lat}_{accel,max} \\alpha^{lat}_{accel,max} maximum allowed acceleration in lateral direction \\delta^{lat}_{min} \\delta^{lat}_{min} fluctuation margin for that needs to be respected when calculating lateral safe distance","title":"Parameter Discussion"},{"location":"ad_rss/Appendix-ParameterDiscussion/#decision-on-selected-parameter-values","text":"Note The following parameter values are only suggestions and open for discussion. These can be changed at anytime, if it is required.","title":"Decision on Selected Parameter Values"},{"location":"ad_rss/HLD-ArchitectureOverview/","text":"RSS System Architecture Overview This section sketches the integration of RSS into a exisiting system architecture. Overview: Sense, Plan, Act, RSS \u00b6 From high level view the architecture of an Automated Driving System (ADS) consists of three main subsystems: Sense, Plan, Act. The world model data provided by the Sense Subsystem is used by the Plan Subsystem to create the near term actuator control commands executed by the Act Subsystem . Integration of RSS into a generic system architecture of an Automated Driving System RSS is integrated into such an ADS architecture by placing it in parallel to the Plan. To provide a safety envelope around the planning output the integration of RSS into a ADS architecture spans into the Sense Subsystem to provide the required RSS world model data as well as into the Act Subsystem to limit the actuator control commands to the RSS restrictions. The Sense Subsystem gathers information on the environment required to fulfill the ADS task. In general there exist several level of perception and fusion which enrich the world model to the extend required for the planning algorithms. In this high-level architecture overview the Sense Subsystem takes over this task. That sketches a slightly different view: RSS foccussed view on the Integration of RSS into a ADS architecture This view stresses on how RSS acts as a Doer-Checker on the Plan Subsystem . At a high level, RSS accomplishes this by doing three key things: Define a safety envelope around the car; the minimum distance, longitudinally and laterally, that should be maintained to avoid danger. By doing this, establish the so called Danger Threshold: the moment in time that the safety envelope has been compromised. RSS acts as a Doer-Checker on the Plan Subsystem of an ADS. With the safety envelope defined, the question is asked: will the planned action compromise that envelope? Is the proposed action unsafe? If RSS determines it is safe, the ADS can act upon it. If not, execute the Proper Response, the third component that defines how the ADS and/or the other party involved must react to get out of the danger and return to a safe state. RSS acting as a Doer-Checker on the planning module Sense Subsystem \u00b6 The Sense Subsystem is responsible for the perception of the environment. It interfaces to the real world by receiving, processing and fusing sensor information. It provides all information in form of the world model to the other ADS subsystems. The exact content of the world model data is highly dependent on the concrete realization of the receiving and processing subsystems, especially the degree of perception and fusion applied will differ. The provided world model data might include raw sensor data, high level object data, but also a-priori knowledge such as AD map data. To account for this the Sense Subsystem provides separate output ports for every connected subsystem. Port Name Explanation Input sensorData The sensor input from the real vehicle or connected simulation Output planWorldModelData The world model data required by the Plan Subsystem Output rssWorldModelData The world model data required by the RSS Subsystem Extract RSS World Model The Extract RSS World Model entity is responsible to transform the internal world model data of the Sense subsytem into the input world model data rssWorldModelData ad::rss::world::WorldModel required by the RSS Subsystem . The user has to implement this functionality as part of the RSS integration efforts into the ADS system. The ad_rss_map_integration library provides an example implementation based on automated driving maps on how such might be calculated and how the global Cartesian data can be transformed into a lane based representation. RSS Subsystem \u00b6 The RSS Subsystem realizes the core RSS functionality. It implements the RSS checks based on the ad::rss::world::WorldModel received from the Extract RSS World Model entity: Do not his someone from behind Do not cut-in recklessly Right-of-Way is given, not taken Be careful in areas with limited visibility [not implemented yet] If you can avoid a crash without causing another, you must [not implemented yet] In case a dangerous situation is detected a proper response and respective acceleration restrictions are calculated to enable the realization of the planning safety on the actuator control commands of the Plan Subsystem . Port Name Explanation Input rssWorldModelData The world model data required to calculate the RSS checks Output rssProperResponse The proper response calculated by RSS Output rssAccelerationRestrictions The restrictions on the vehicle acceleration calculated by RSS Extract Situations The Extract Situations entity transforms the world model data into individual RssSituations between the ego vehicle and each of the objects. For every scene ad::rss::world::Scene of the input world model data the individual (relative) situation ad::rss::situation::Situation is calculated. Port Name Explanation Input rssWorldModelData Lane based world model scenes on the surrounding environment required to create the situation based coordinate system. Requires local map data (i.e. lane segments and semantics on intersections and priority rules), ego vehicle and object (i.e. position, velocity and RSS dynamics) information. Output rssSituations A list of individual RSS Situations between the ego vehicle and each of the objects. Each situation is formulated within its own situation based coordinate system. EgoVehicle and Objects: i.e. (relative) position, velocity, priority flag, situation specific RSS acceleration values. Check Situations The Check Situations entity performs the RSS check on all incoming individual RssSituations and creates the RssStates ad::rss::state::RssState containing the required responses if dangerous situations are detected. Port Name Explanation Input rssSituations A list of individual RSS Situations between the ego vehicle and each of the objects. Output rssStates A list of RSS states in respect to the individual RSS Situations including situation specific responses. Resolve and Transform Responses The Resolve and Transform Responses entity handles conflicts of the incoming RssStates. It combines the individual situation specific responses into one single overall RssProperResponse ad::rss::state::ProperResponse and transforms these into RssAccelerationRestrictions ad::rss::world::AccelerationRestriction for the actuator commands. Port Name Explanation Input rssStates A list of RssStates in respect to the individual RssSituations Output rssProperResponse Resulting combined overall proper response Output rssAccelerationRestrictions The resulting restrictions of the actuator control command Plan Subsystem \u00b6 The Plan subsystem performs the decision-making of the ADS. It analyses the provided planWorldModelData and decides what action to take. Finally, this leads to concrete control commands for the ADS Act Subsystem defining the next move of the ADS. Port Name Explanation Input planWorldModelData The world model data required by the Plan Subsystem Output actuatorControlCommand The control commands to realize the next moves within the current plan Act Subsystem \u00b6 The Act Subsystem executes the moves which the Plan Subsystem has calculated. It receives the ActuatorControlCommands controlling i.e. acceleration, braking and steering to execute the plan. Port Name Explanation Input actuatorControlCommand The control commands to realize the next moves within the current plan. Input rssAccelerationRestrictions The restrictions on the acceleration for the vehicle calculated by RSS. Output controlData The control output for the real vehicle or connected simulation Enforce RSS Restrictions The Enforce RSS Restrictions entity receives the actuator control commands from the Plan Subsystem and restricts the control values according to the restrictions calculated by RSS. The resulting actuator control commands are safe in respect to RSS rules. This calculation heavily depends on the actual representation of the ActuatorControlCommands data. Therefore, a generic implementation is not possible and the user has to implement this functionality as part of the RSS integration efforts into the ADS. Port Name Explanation Input rssAccelerationRestrictions The restrictions on the acceleration for the vehicle calculated by RSS. Input actuatorControlCommandIn The control commands from the Plan Subsystem to control the vehicle actuator system Output actuatorControlCommandOut The adapted control commands from the Plan Subsystem to control the vehicle actuator system in a RSS safe manner","title":"System Integration"},{"location":"ad_rss/HLD-ArchitectureOverview/#overview-sense-plan-act-rss","text":"From high level view the architecture of an Automated Driving System (ADS) consists of three main subsystems: Sense, Plan, Act. The world model data provided by the Sense Subsystem is used by the Plan Subsystem to create the near term actuator control commands executed by the Act Subsystem . Integration of RSS into a generic system architecture of an Automated Driving System RSS is integrated into such an ADS architecture by placing it in parallel to the Plan. To provide a safety envelope around the planning output the integration of RSS into a ADS architecture spans into the Sense Subsystem to provide the required RSS world model data as well as into the Act Subsystem to limit the actuator control commands to the RSS restrictions. The Sense Subsystem gathers information on the environment required to fulfill the ADS task. In general there exist several level of perception and fusion which enrich the world model to the extend required for the planning algorithms. In this high-level architecture overview the Sense Subsystem takes over this task. That sketches a slightly different view: RSS foccussed view on the Integration of RSS into a ADS architecture This view stresses on how RSS acts as a Doer-Checker on the Plan Subsystem . At a high level, RSS accomplishes this by doing three key things: Define a safety envelope around the car; the minimum distance, longitudinally and laterally, that should be maintained to avoid danger. By doing this, establish the so called Danger Threshold: the moment in time that the safety envelope has been compromised. RSS acts as a Doer-Checker on the Plan Subsystem of an ADS. With the safety envelope defined, the question is asked: will the planned action compromise that envelope? Is the proposed action unsafe? If RSS determines it is safe, the ADS can act upon it. If not, execute the Proper Response, the third component that defines how the ADS and/or the other party involved must react to get out of the danger and return to a safe state. RSS acting as a Doer-Checker on the planning module","title":"Overview: Sense, Plan, Act, RSS"},{"location":"ad_rss/HLD-ArchitectureOverview/#sense-subsystem","text":"The Sense Subsystem is responsible for the perception of the environment. It interfaces to the real world by receiving, processing and fusing sensor information. It provides all information in form of the world model to the other ADS subsystems. The exact content of the world model data is highly dependent on the concrete realization of the receiving and processing subsystems, especially the degree of perception and fusion applied will differ. The provided world model data might include raw sensor data, high level object data, but also a-priori knowledge such as AD map data. To account for this the Sense Subsystem provides separate output ports for every connected subsystem. Port Name Explanation Input sensorData The sensor input from the real vehicle or connected simulation Output planWorldModelData The world model data required by the Plan Subsystem Output rssWorldModelData The world model data required by the RSS Subsystem","title":"Sense Subsystem"},{"location":"ad_rss/HLD-ArchitectureOverview/#rss-subsystem","text":"The RSS Subsystem realizes the core RSS functionality. It implements the RSS checks based on the ad::rss::world::WorldModel received from the Extract RSS World Model entity: Do not his someone from behind Do not cut-in recklessly Right-of-Way is given, not taken Be careful in areas with limited visibility [not implemented yet] If you can avoid a crash without causing another, you must [not implemented yet] In case a dangerous situation is detected a proper response and respective acceleration restrictions are calculated to enable the realization of the planning safety on the actuator control commands of the Plan Subsystem . Port Name Explanation Input rssWorldModelData The world model data required to calculate the RSS checks Output rssProperResponse The proper response calculated by RSS Output rssAccelerationRestrictions The restrictions on the vehicle acceleration calculated by RSS","title":"RSS Subsystem"},{"location":"ad_rss/HLD-ArchitectureOverview/#plan-subsystem","text":"The Plan subsystem performs the decision-making of the ADS. It analyses the provided planWorldModelData and decides what action to take. Finally, this leads to concrete control commands for the ADS Act Subsystem defining the next move of the ADS. Port Name Explanation Input planWorldModelData The world model data required by the Plan Subsystem Output actuatorControlCommand The control commands to realize the next moves within the current plan","title":"Plan Subsystem"},{"location":"ad_rss/HLD-ArchitectureOverview/#act-subsystem","text":"The Act Subsystem executes the moves which the Plan Subsystem has calculated. It receives the ActuatorControlCommands controlling i.e. acceleration, braking and steering to execute the plan. Port Name Explanation Input actuatorControlCommand The control commands to realize the next moves within the current plan. Input rssAccelerationRestrictions The restrictions on the acceleration for the vehicle calculated by RSS. Output controlData The control output for the real vehicle or connected simulation","title":"Act Subsystem"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/","text":"ad-rss-lib Realization RSS checks and response \u00b6 To check whether the ego vehicle is in a safe state, all the objects in the surrounding must be respected. To do so the ad-rss-lib will perform an analysis against all the objects in the environment individually. Meaning, for each object in the environment the ad-rss-lib will check whether the ego vehicle conflicts with this object. Therefore, longitudinal and lateral checks are performed. As mentioned earlier, these checks are performed separately for each object - ego vehicle pair, i.e. for each situation. At this, the type of situation has to be evaluated upfront outside of this library implementation. Otherwise, this RSS implementation would enforce a concrete representation of the environment and i.e. the map data with lanes, intersections and priority rules. The situations types that have to be identified are: both vehicles drive on the same road in the same direction in opposite direction both vehicles drive on different roads that are connected by an intersection the ego vehicle has priority over the other vehicle the other vehicle has priority over the ego vehicle both vehicles have same priority (no vehicle has priority over the other vehicle) Longitudinal conflicts \u00b6 The behavior for longitudinal conflicts (checks and response) for vehicles driving in the same direction are implemented as described in the definitions 1, 3 and 4 of the RSS paper . For the case of vehicles driving in opposite directions, the implementation follows the definitions 2, 3 and 4 of the paper. In detail, the current realization looks as follows: Same direction If the longitudinal distance is not safe and if the ego vehicle is in front, the other vehicle has to break longitudinally. There is no longitudinal response for the ego vehicle issued. otherwise, the ego vehicle has to break longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Opposite direction If the longitudinal distance is not safe and if the ego vehicle is driving in the correct direction, the ego vehicle has to break longitudinally with at least \\alpha_{min,brake,correct} \\alpha_{min,brake,correct} . otherwise, the ego vehicle has to break longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Lateral conflicts \u00b6 The lateral checks and the proper response follow the definitions 5, 6, 7 and 8 of the RSS paper . In detail, the current realization looks as follows: If the lateral distance is not safe and if the ego vehicle is on the left side, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on the right side if the ego vehicle is on the right side, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on the left side otherwise, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on both sides Combining longitudinal and lateral response \u00b6 The combination of longitudinal and lateral response of a single situation (object - ego vehicle pair) is implemented as described in definitions 9 and 10 of the RSS paper . In detail, the current realization looks as follows: If the situation is dangerous (i.e. there exists a longitudinal and a lateral conflict), the stored last non-dangerous state of the of the same situation (ego-vehicle - object pair) is checked: if there was no lateral conflict, the combined response breaks laterally if there was no longitudinal conflict, the combined response breaks longitudinally Combining all situations of a given point in time \u00b6 Since this RSS implementation performs the above mentioned check separately for each situation, the overall response of the ego vehicle has to consider all individual situations of the current scene. The current realization loops over all situations and combines the lateral left, the lateral right and the longitudinal response states of these by selecting the most severe response of each component respectively. Important This initial implementation does not yet cover evasive maneuvers to compensate for improper behavior of others according to definitions 11, 12 and 13 of the RSS paper . If the car finds itself in a dangerous situation one possible action is always to brake. This should always result in a safe state, if both vehicles respond properly according to RSS. Improper behavior of others might still lead to an accident. This is where evasive maneuver could prevent from this. To do so, it must be assured that this lateral movement brings the vehicle into a safe state and does not conflict with another vehicle. In order to determine whether a lateral movement solves the conflict a prediction of the state would be necessary. Such a naive predication following definition 11 of the paper is not available yet in this initial implementation. In addition, the ad-rss-lib currently has no notion of drivable freespace area. Hence, it cannot determine that an evasive maneuver initiated by RSS will cause an accident with an obstacle or forces the vehicle to leave the road. Therefore, it is impossible for the ad-rss-lib in its current form to detect whether a lateral evasion is really feasible. Hence, the ad-rss-lib will not initiate a lateral evasive maneuver according to definitions 12 and 13 of the paper. Instead, it will only restrict the movement in the dangerous direction. Please note that this restriction does not hinder the driving policy to find a better escape for the current situation. If this is the case, for example by braking harder, or changing lanes quicker, RSS will not forbid this maneuver, as long as it does not create another conflict, and is compliant with the restrictions calculated by RSS. Handling of Intersections \u00b6 The behavior for intersection conflicts (checks and response) for vehicles is implemented as described in the definitions 16, 17 and 18 of the RSS paper In detail, the current realization looks as follows: It is checked, if a non-prioritized vehicle was able to stop in front of the intersection. If this is the case, the non-prioritized vehicle is supposed to brake, whereas the prioritized vehicle can continue driving as before. If 1. does not hold, it is checked, if there is a safe longitudinal distance between the two vehicles according to Definition 17.2 of the RSS paper . In this case, the leading vehicle can continue driving, whereas the following vehicle has to respect the \"stated braking pattern\". If 1. and 2. do not hold, there is a time period in which both vehicles may be crossing the intersection. In this case Definition 18.3 of the RSS paper applies, i.e. both cars have to brake laterally and longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Note Case 1. is the direct realization of Definition 17.1, where it is mentioned that the vehicle was able to stop safely. However, as a consequence, the prioritized vehicle is not forced to brake, if the non-prioritized vehicle does not respect RSS. Since the evasive maneuvers are not yet implemented such kind of improper behavior cannot be handled by the current ad-rss-lib. Important In the current realization of the ad-rss-lib, it is assumed that there is always a lateral conflict in case of intersections. This will be addressed in future. Response Time and Other Parameters \u00b6 According to the papers each traffic participant has a response time, and is objected to respect certain acceleration limits (e.g. maximum acceleration \\alpha_{accel,max} \\alpha_{accel,max} , maximum deceleration \\alpha_{brake,max} \\alpha_{brake,max} , etc.). Within this response time the participants (including the ego vehicle) are allowed to accelerate with at most \\alpha_{accel,max} \\alpha_{accel,max} , and thus increase their velocity. The distance covered during the response time is part of the safe distance, as defined by RSS. Hence, upon entering a dangerous situation, it would be possible to accelerate with up to \\alpha_{accel,max} \\alpha_{accel,max} for at most t < response time, as this acceleration is already considered. Note It is important to note that the implementation of the ad-rss-lib in the library only uses parameters, but not the exact value. By this means, the library is independent to changes of the parameter values. Instead, the user defines a feasible parameter set, which is provided as input to the ad-rss-lib. A discussion on the parameter selection can be found in the parameter discussion section . Situation-Based Coordinate System \u00b6 As described in the RSS paper in section 3.2 \"Preliminaries \u2014 A Lane-Based Coordinate System\", all RSS calculations are based on a lane-centric coordinate system. This system uses adjacent, straight lanes of constant width, and thus requires a transformation of the object states from Cartesian into the lane space. This transformation into a lane-based coordinate system is described by a bijective function, as pointed out by paper 1. Therein, the lateral position of a vehicle within the lane is mapped to a parametric interval [ -0.5; 0.5 ], where the lane boundaries are fixed at the borders of the interval. The advantage of such a coordinate system over the Cartesian system is that it allows the direct calculation of longitudinal and lateral distances of objects. However, when transforming the Cartesian space into a lane-based coordinate system, several challenges have to be taken into consideration. Comparing movements in lane-based coordinate systems \u00b6 During the transformation process to a lane-based coordinate system, not only the position but also the the velocities and accelerations have to be transformed. As a matter of fact, the resulting values depend on the actual lane geometry, and thus, velocities and accelerations of different lane-based coordinate systems cannot be compared to each other anymore (ego vehicle - object pair). To illustrate this problems, let us consider the following examples: Discontinuity Problem: Two parallel lanes, different width Figure 1: Two parallel lanes with different width causing a discontinuity in lateral acceleration Let us illustrate this on a simple example with two parallel lanes of different width. Let the left lane A have a constant width of 4 m where the right lane B only has a constant width of 2 m . If both lanes define their own lane-based coordinate system LCS_A LCS_A and LCS_B LCS_B , a Cartesian lateral acceleration value of 1 m/ s^2 s^2 becomes 0.25 lat/ s^2 s^2 in LCS_A LCS_A and 0.5 lat/ s^2 s^2 in LCS_B LCS_B . Therefore, the formula for constant accelerated movement has to use different acceleration constants in different lanes. This situation is getting even worse, if a car is changing the lane from lane A to lane B: then the closed formula for constant accelerated movement to calculate the lateral distance over time cannot be applied anymore directly. Changing Acceleration Problem: Lane is widening/narrowing Figure 2: Changing lane width and its impact on the lateral acceleration Let us consider a lane with changing width in another example. If the lane's width at the beginning is 4 m and 100 m away the lane is narrowing to 2 m . In such a case the Cartesian lateral acceleration value of 1 m/ s^2 s^2 is changing from 0.25 lat/ s^2 s^2 at the beginning towards 0.5 lat/ s^2 s^2 while advancing within the lane. Changing Distances Problem: Lane with a narrow curve Figure 3: Lane describing a narrow 180\u00b0 curve and its impact on driven distances This section illustrates a longitudinal situation similar to the lane widening example. Let us assume the lane has a constant width of 4 m describing a curve with inner radius of 50 m covering 180\u00b0 . The inner border of the lane has a length of about 157.1 m , the center line 163.4 m the outer border 169.7 m . In that situation a longitudinal acceleration value will evaluate to 1.0 lon/ s^2 s^2 for the center line, 0.96 lon/ s^2 s^2 for the outer border and 1.04 lon/ s^2 s^2 for the inner border. Therefore, the longitudinal acceleration changes over time, if the vehicle changes its lateral position within the lane. Summary As sketched in the previous sections both the longitudinal as well as the lateral acceleration values, as well as velocities within the lane-based coordinate system cannot be considered as constant anymore. Moreover, these values do not only change within one coordinate system, but also when changing from one lane-based system to another one. To overcome this issue, we use a \"Situation-Based Coordinate System\" , that is described in detail in the next section. This system is unique for each situation (ego vehicle - object pair) and comprises all lanes required to describe this situation. Chosen Design: Individual Situation-Based Coordinate System As RSS performs a worst case assessment, the idea followed by the ad-rss-lib implementation is to calculate the min/max position values of the vehicles within the situation specific coordinate system. According to the constellation of the vehicles within the situation, the respective worst case lateral and longitudinal border values are selected and processed by the RSS formulas. Like this, it is assured that the calculations are sound, nevertheless this might lead to a more cautious behavior of the vehicle. The following subsections describe the selected approach in more detail. Two parallel lanes, different width As described in the previous section, the border between neighboring lanes of different width introduces discontinuities of the lateral acceleration values (see Figure 1). As the ad-rss-lib judges the relative situation between the ego vehicle and the other objects one by one individually, it is not required to distinguish between the actual lanes within the individual distance calculations. Combining all lanes relevant for the individual situation s_i s_i between ego vehicle and object o_i o_i into one single situation-based coordinate system SCS_i SCS_i resolves all discontinuities, as depicted in Figure 4. Figure 4: Avoid discontinuities by using one single situation-based coordinate system Coming back to the concrete example from Figure 1, left lane A having a constant width of 4 m and right lane B having a constant width of 2 m , both lanes together have a resulting width of 6 m and form an area with continuous lateral acceleration (see also illustration in Figure 4). The check of the ego vehicle with another object o_j o_j which is two lanes at the right of the ego vehicle in a lane C having a constant width of 3 m , has to take all three lanes into account with resulting width of 9 m . Therefore, a different situation-based coordinate system SCS_j SCS_j is required, when checking another object. Lane is widening or has a narrow curve The individual situation specific coordinate system SCS SCS does not yet cover the situations of widening lanes or narrow curves. To take the variation of the lane width and length into account, it is required to apply the extrema within the respective SCS SCS accordingly. Again, coming back to the examples from above, let us have a lane with non constant width between 2 m and 4 m . Then the transformation of the maximal possible lateral position value of the vehicle into the situation coordinate system SCS SCS has to take the maximum width of 4 m into account, while the transformation of the minimal possible lateral position has to be transformed with the minimum width of the lane of 2 m . Like this it is guaranteed that we don't underestimate the distances of the vehicles towards each other. As a result, it is ensured that under all conditions, the safety distances are calculated in a conservative manner. In a similar way, it is possible to transform the longitudinal position values into the situation-based coordinate system SCS_k SCS_k . Note The performed operations can be interpreted as enlarging the vehicles bounding boxes to ensure the worst case is covered. Road area To overcome the problems of discontinuities, changing lateral and longitudinal distances resulting in not comparable velocities and accelerations the situation based coordinate system merges in a first step all lanes segments relevant to the situation (ego vehicle - object pair) into one situation specific metric road area. One can imagine this step as the creation of a bounding box around the two vehicles that is large enough to cover the relevant positions of those while ignoring actual markings on the road between the lanes. By this, especially the physical lateral velocities and accelerations within the Cartesian 2D space of the road area can be measured and calculated straight forward without any discontinuities (see also the illustrations in Figure 5 and Figure 6). Figure 5: Creation of the situation-based coordinate system: The road area (red) consists of all lane segments along the road relevant for the situation between the two vehicles Figure 6: Creation of the situation-based coordinate system: Worst-case transformation of the vehicle bounding box. The metric road on the left leads to transformed vehicles and their bounding boxes (red) on the right, sketched for a narrowing road area at the top and a curve at the bottom. It is worth to mention, that in these calculations the actual shape of the lane is not used. Therefore, detailed knowledge of the actual lane geometry is not required. The absolute maximum and minimum width and length values of the lane segments is sufficient to calculate a proper transformation into the space of the situation specific coordinate systems. Note In case of intersections both vehicles define their own road areas including the intersecting parts. The case that a lane is ending or two lanes are merged into one single lane have to be treated like intersections since a lateral conflict is unavoidable. Considerations on reverse transformation of the proper response As the proper response is referring to the situation-based coordinate systems, the response has to be transformed back considering the actual lane geometry. Therefore, first the transformation into the vehicle-specific lane-based coordinate system is required, and then the transformation into the Cartesian space is performed. A simple example illustrates this: a vehicle driving in a curve will for sure have to perform a lateral acceleration in Cartesian space otherwise it will leave the lane because of the centripetal force, as illustrated in Figure 7. However, in the vehicle specific lane-based system the lateral acceleration will be 0. Figure 7: Constant drive around a curve will result in a zero lateral acceleration in a lane-based coordinate system and in a non-zero acceleration in a cartesian system Because the proper response of RSS is defined with respect to the actual lane the vehicle is driving in, it is required to assure that the reverse transformation of the proper response considers only the ego-lane and not the complete situation specific coordinate systems. For example, let us consider a scenario as depicted in Figure 8, where one widening lane A and one narrowing lane B are neighbors in such a way that the overall width of the road is constantly 6 m . Lane A starts with 2 m and ends with 4 m width, whereas lane B starts with 4 m and ends with 2 m width. A lateral velocity of 0 in respect to the whole road differs from the definition of a lateral velocity of 0 in lane A/lane B in Cartesian space. Figure 8: Different lateral accelerations in a lane-based system and Cartesian system for a vehicle following the centerline of lane B Note It is worth to note that in the particular implementation of the ad-rss-lib in the library at hand, the reverse transformation from the situation-specific into a vehicle-centric lane coordinate system is not required, as the RSS response is defined such that it is independent of these two coordinate system. Summary The presented construction of a continuous situation-based coordinates system will allow the pairwise calculation of the safe distances between ego vehicle and objects with the assumption of constant acceleration. Still, the worst case assessment of RSS is not violated. This situation-based coordinate system in conjunction with the situation specific consideration of the position extrema allows the calculation of the safe distances, the decision on dangerous situations and deduction of a proper response. The main benefits of the selected Situation Based Coordinate System definition are: * Velocity and acceleration values in longitudinal and lateral lane directions do not change when transforming into the situation based coordinate system * All formulas for constant accelerated movement can be applied in the situation based coordinate space. * Distance calculations in situation based coordinate systems are simple additions or subtractions * The transformation into the situation based coordinate system is simple and therefore can be implemented easily with the restricted computational resources of safety controllers For safety considerations, it is crucial to do all calculations considering the worst case assumption. Therefore, it is required to choose the correct minimum or maximum value of the positions in the situation-based coordinate system to assure that always the worst case is considered. Design alternative: Iterative Approach [optional] \u00b6 Figure 9: Illustration of an iterative approach to calculate non-constant acceleration, velocity etc. Another possible way to handle the non-constant acceleration values would be an iterative approach: based on the position, the velocity and the acceleration values at the given position at time t_0 t_0 , the position at time t_1 t_1 is calculated. The smaller the time interval between the iteration steps is chosen, the smaller the calculation error gets (see figure above). One drawback of the iterative approach is that the RSS implementation has to get to know the lane geometries in detail to be able to calculate the acceleration values to be used for every position within the situation-based coordinate systems. Therefore, this design approach is not selected by this ad-rss-lib implementation. Summary \u00b6 Summary RSS checks are performed on the current state on a ego vehicle - object pair basis In dangerous situations only braking maneuvers are issued. RSS does not initiate evasive maneuvers, but will not hinder the driving policy to execute lateral evasive maneuvers, as long as these are compliant with the required RSS response. To handle changing lateral/longitudinal lane geometries when transforming the Cartesian space into the situation based coordinate system, the vehicles position extrema are chosen in such a way that accelerations can still be treated as constant, but guarantee safe operation (see < >).","title":"Design Discussions"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#rss-checks-and-response","text":"To check whether the ego vehicle is in a safe state, all the objects in the surrounding must be respected. To do so the ad-rss-lib will perform an analysis against all the objects in the environment individually. Meaning, for each object in the environment the ad-rss-lib will check whether the ego vehicle conflicts with this object. Therefore, longitudinal and lateral checks are performed. As mentioned earlier, these checks are performed separately for each object - ego vehicle pair, i.e. for each situation. At this, the type of situation has to be evaluated upfront outside of this library implementation. Otherwise, this RSS implementation would enforce a concrete representation of the environment and i.e. the map data with lanes, intersections and priority rules. The situations types that have to be identified are: both vehicles drive on the same road in the same direction in opposite direction both vehicles drive on different roads that are connected by an intersection the ego vehicle has priority over the other vehicle the other vehicle has priority over the ego vehicle both vehicles have same priority (no vehicle has priority over the other vehicle)","title":"RSS checks and response"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#longitudinal-conflicts","text":"The behavior for longitudinal conflicts (checks and response) for vehicles driving in the same direction are implemented as described in the definitions 1, 3 and 4 of the RSS paper . For the case of vehicles driving in opposite directions, the implementation follows the definitions 2, 3 and 4 of the paper. In detail, the current realization looks as follows:","title":"Longitudinal conflicts"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#lateral-conflicts","text":"The lateral checks and the proper response follow the definitions 5, 6, 7 and 8 of the RSS paper . In detail, the current realization looks as follows: If the lateral distance is not safe and if the ego vehicle is on the left side, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on the right side if the ego vehicle is on the right side, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on the left side otherwise, the ego vehicle has to break laterally with at least \\alpha^{lat}_{brake,min} \\alpha^{lat}_{brake,min} on both sides","title":"Lateral conflicts"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#combining-longitudinal-and-lateral-response","text":"The combination of longitudinal and lateral response of a single situation (object - ego vehicle pair) is implemented as described in definitions 9 and 10 of the RSS paper . In detail, the current realization looks as follows: If the situation is dangerous (i.e. there exists a longitudinal and a lateral conflict), the stored last non-dangerous state of the of the same situation (ego-vehicle - object pair) is checked: if there was no lateral conflict, the combined response breaks laterally if there was no longitudinal conflict, the combined response breaks longitudinally","title":"Combining longitudinal and lateral response"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#combining-all-situations-of-a-given-point-in-time","text":"Since this RSS implementation performs the above mentioned check separately for each situation, the overall response of the ego vehicle has to consider all individual situations of the current scene. The current realization loops over all situations and combines the lateral left, the lateral right and the longitudinal response states of these by selecting the most severe response of each component respectively. Important This initial implementation does not yet cover evasive maneuvers to compensate for improper behavior of others according to definitions 11, 12 and 13 of the RSS paper . If the car finds itself in a dangerous situation one possible action is always to brake. This should always result in a safe state, if both vehicles respond properly according to RSS. Improper behavior of others might still lead to an accident. This is where evasive maneuver could prevent from this. To do so, it must be assured that this lateral movement brings the vehicle into a safe state and does not conflict with another vehicle. In order to determine whether a lateral movement solves the conflict a prediction of the state would be necessary. Such a naive predication following definition 11 of the paper is not available yet in this initial implementation. In addition, the ad-rss-lib currently has no notion of drivable freespace area. Hence, it cannot determine that an evasive maneuver initiated by RSS will cause an accident with an obstacle or forces the vehicle to leave the road. Therefore, it is impossible for the ad-rss-lib in its current form to detect whether a lateral evasion is really feasible. Hence, the ad-rss-lib will not initiate a lateral evasive maneuver according to definitions 12 and 13 of the paper. Instead, it will only restrict the movement in the dangerous direction. Please note that this restriction does not hinder the driving policy to find a better escape for the current situation. If this is the case, for example by braking harder, or changing lanes quicker, RSS will not forbid this maneuver, as long as it does not create another conflict, and is compliant with the restrictions calculated by RSS.","title":"Combining all situations of a given point in time"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#handling-of-intersections","text":"The behavior for intersection conflicts (checks and response) for vehicles is implemented as described in the definitions 16, 17 and 18 of the RSS paper In detail, the current realization looks as follows: It is checked, if a non-prioritized vehicle was able to stop in front of the intersection. If this is the case, the non-prioritized vehicle is supposed to brake, whereas the prioritized vehicle can continue driving as before. If 1. does not hold, it is checked, if there is a safe longitudinal distance between the two vehicles according to Definition 17.2 of the RSS paper . In this case, the leading vehicle can continue driving, whereas the following vehicle has to respect the \"stated braking pattern\". If 1. and 2. do not hold, there is a time period in which both vehicles may be crossing the intersection. In this case Definition 18.3 of the RSS paper applies, i.e. both cars have to brake laterally and longitudinally with at least \\alpha_{min,brake} \\alpha_{min,brake} . Note Case 1. is the direct realization of Definition 17.1, where it is mentioned that the vehicle was able to stop safely. However, as a consequence, the prioritized vehicle is not forced to brake, if the non-prioritized vehicle does not respect RSS. Since the evasive maneuvers are not yet implemented such kind of improper behavior cannot be handled by the current ad-rss-lib. Important In the current realization of the ad-rss-lib, it is assumed that there is always a lateral conflict in case of intersections. This will be addressed in future.","title":"Handling of Intersections"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#response-time-and-other-parameters","text":"According to the papers each traffic participant has a response time, and is objected to respect certain acceleration limits (e.g. maximum acceleration \\alpha_{accel,max} \\alpha_{accel,max} , maximum deceleration \\alpha_{brake,max} \\alpha_{brake,max} , etc.). Within this response time the participants (including the ego vehicle) are allowed to accelerate with at most \\alpha_{accel,max} \\alpha_{accel,max} , and thus increase their velocity. The distance covered during the response time is part of the safe distance, as defined by RSS. Hence, upon entering a dangerous situation, it would be possible to accelerate with up to \\alpha_{accel,max} \\alpha_{accel,max} for at most t < response time, as this acceleration is already considered. Note It is important to note that the implementation of the ad-rss-lib in the library only uses parameters, but not the exact value. By this means, the library is independent to changes of the parameter values. Instead, the user defines a feasible parameter set, which is provided as input to the ad-rss-lib. A discussion on the parameter selection can be found in the parameter discussion section .","title":"Response Time and Other Parameters"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#situation-based-coordinate-system","text":"As described in the RSS paper in section 3.2 \"Preliminaries \u2014 A Lane-Based Coordinate System\", all RSS calculations are based on a lane-centric coordinate system. This system uses adjacent, straight lanes of constant width, and thus requires a transformation of the object states from Cartesian into the lane space. This transformation into a lane-based coordinate system is described by a bijective function, as pointed out by paper 1. Therein, the lateral position of a vehicle within the lane is mapped to a parametric interval [ -0.5; 0.5 ], where the lane boundaries are fixed at the borders of the interval. The advantage of such a coordinate system over the Cartesian system is that it allows the direct calculation of longitudinal and lateral distances of objects. However, when transforming the Cartesian space into a lane-based coordinate system, several challenges have to be taken into consideration.","title":"Situation-Based Coordinate System"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#comparing-movements-in-lane-based-coordinate-systems","text":"During the transformation process to a lane-based coordinate system, not only the position but also the the velocities and accelerations have to be transformed. As a matter of fact, the resulting values depend on the actual lane geometry, and thus, velocities and accelerations of different lane-based coordinate systems cannot be compared to each other anymore (ego vehicle - object pair). To illustrate this problems, let us consider the following examples:","title":"Comparing movements in lane-based coordinate systems"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#design-alternative-iterative-approach-optional","text":"Figure 9: Illustration of an iterative approach to calculate non-constant acceleration, velocity etc. Another possible way to handle the non-constant acceleration values would be an iterative approach: based on the position, the velocity and the acceleration values at the given position at time t_0 t_0 , the position at time t_1 t_1 is calculated. The smaller the time interval between the iteration steps is chosen, the smaller the calculation error gets (see figure above). One drawback of the iterative approach is that the RSS implementation has to get to know the lane geometries in detail to be able to calculate the acceleration values to be used for every position within the situation-based coordinate systems. Therefore, this design approach is not selected by this ad-rss-lib implementation.","title":"Design alternative: Iterative Approach [optional]"},{"location":"ad_rss/HLD-KeyDesignDecisionsAndAlternatives/#summary","text":"Summary RSS checks are performed on the current state on a ego vehicle - object pair basis In dangerous situations only braking maneuvers are issued. RSS does not initiate evasive maneuvers, but will not hinder the driving policy to execute lateral evasive maneuvers, as long as these are compliant with the required RSS response. To handle changing lateral/longitudinal lane geometries when transforming the Cartesian space into the situation based coordinate system, the vehicles position extrema are chosen in such a way that accelerations can still be treated as constant, but guarantee safe operation (see < >).","title":"Summary"},{"location":"ad_rss/HLD-Safety/","text":"Design for Safety \u00b6 In principle, RSS is implementing safety of the intended functionality (SOTIF). One can apply RSS without general functional safety (FuSa) aspects to safeguard the planning functionality. If RSS is implemented in an ADS with FuSa constraints on system level, RSS contributes to the FuSa goals of the whole ADS.","title":"Safety"},{"location":"ad_rss/HLD-Safety/#design-for-safety","text":"In principle, RSS is implementing safety of the intended functionality (SOTIF). One can apply RSS without general functional safety (FuSa) aspects to safeguard the planning functionality. If RSS is implemented in an ADS with FuSa constraints on system level, RSS contributes to the FuSa goals of the whole ADS.","title":"Design for Safety"},{"location":"ad_rss/HLD-Security/","text":"Design for Security \u00b6 This chapter discusses security aspects. Architecture and dataflow \u00b6 As a reminder of the high-level architecture, we refer to two figures from the integration chapter . The RSS Subsystem within the autonomous driving (AD) system has a single input called rssWorldModelData , and outputs called rssProperResponse and rssAccelerationRestrictions . The section decribes further details of the RSS function including the internal calculation steps and internal dataflow. In addition, we refer to the C++ software class ad::rss::core::RssCheck that implements the external RSS interface. The top-level external interface is implemented using a single routine, called calculateAccelerationRestriction() , which is a member function of the RssCheck class. This routine has a single input, called worldModel (of type ad::rss::world::WorldModel , and a single output, called accelerationRestriction of type ad::rss::world::AccelerationRestriction . The library is single-thread, does not make network connections, and does not make connections with other processes remote or local. The library does not make use of any 3rd party components besides logging capabilities, and as such does not have additional security dependencies. The primary adversary model is one where invalid/incorrect input data could be provided to the library input interface by the system or from an upstream source. In the following sections, we discuss security aspects related to: input data (implemented by ad::rss::world::WorldModel ), output data (implemented by ad::rss::world::AccelerationRestrictions ), and the RSS function itself (implemented by ad::rss::core::RssCheck ` and supporting library classes). RSS input data ( ad::rss::world::WorldModel ) \u00b6 Input data source The input data is contained in ad::rss::world::WorldModel . This data includes distances to other road agents (vehicles and other) and velocities of other road agents. This data also includes description of the geometry of the road (and road lanes). The data contained in ad::rss::world::WorldModel is provided directly by a calling routine external to the RSS library. Typically, this data will ultimately originate from the vehicle sensing subsystem, but it is the responsibility of the calling routine to receive, convert, and provide this sensing-derived data to the RSS function in the correct format. The calling routine must ensure the integrity of the input data provided to the RSS library functions. Validity of input data and error handling The library attempts to ensure the validity of the input data, and handle cases of improper or invalid input data, in several ways. Several explicit checks of the input data validity are performed, including the following. Check that the data structure describing the local road and lane geometries is internally consistent. The description of a local road follows basic constraints, and if the description is inconsistent with these constraints, the routine that analyzes the situation from the input data returns, with the success/fail flag set to fail . Check that the data structures describing the ego-vehicle or other objects (other vehicles) are internally consistent. The routine that analyzes the situation checks against basic constraints. If the constraints are violated, the routine returns with the success/fail flag set to fail . For this, the routines withinValidInputRange() are used. The respective Doxygen description of these contains the absolute values against which the inputs (like e.g. velocities, accelerations, etc.) are checked. Error handling: Each routine in the library that invokes subroutines checks a success/fail flag returned by the subroutine. In addition, many routines perform custom checking of the internal logic against known constraints of RSS. A failure of a logic check or of a subroutine results in interruption of the routine and a fail flag being passed to the calling routine. Exception handling: The code-blocks in high-level routines are enclosed inside C++ try-catch blocks. Any exception thrown at lower-level software routines results in a fail flag being returned to the caller of the publicly available high-level routines. When any of the above errors occur, the top-level RSS routine, ad::rss:core::RssCheck::calculateAccelerationRestriction() , will return with the success/fail flag set to fail . Logging: The top-level routine in the library returns a success/fail flag that can be recorded by logging functions that may be available in the overall AD system (external to the library). The reason for the failure is logged using the global logger defined by spdlog . Non-functional requirements The size of the input data ad::rss::world::WorldModel provided to ad::rss::core::RssCheck is determined by the number of other objects (other vehicles or road agents) that the ego-vehicle is interacting with, and the size of the description of each object and associated road areas. Based on this, it is straightforward to bound the size of data that must be consumed by the ad::rss::core::RssCheck in a single call, based on the sizes of individual datatypes and by bounding the number of objects. It is the responsibility of the system integrator to determine the number of objects the system can handle and to bound the size of the input data. It is the responsibility of the system integrator to determine an appropriate rate or a maximum rate at which the top-level routine, ad::rss::core::RssCheck::calculateAccelerationRestriction() , should be invoked. The latency resulting from the processing time of ad::rss::core::RssCheck::calculateAccelerationRestriction() should be strictly limited, due to the real-time nature of the AD system and closed-loop interaction with the real world environment. This latency should be less than the time period (1/rate) of the Act Subsystem . It is the responsibility of the system integrator to ensure that this is achieved, or to achieve a latency below an upper bound that is tighter (lower) than the one mentioned here. RSS output data ( ad::rss::world::AccelerationRestriction ) \u00b6 ad::rss::core::RssCheck::calculateAccelerationRestriction() outputs a structure of type ad::rss::world::AccelerationRestriction . This is a very small structure that contains three ranges of acceleration allowed by RSS: allowable range of longitudinal acceleration, allowable range of lateral acceleration to the left of the vehicle, and allowable range of lateral acceleration to the right of the vehicle. Each acceleration range consists of two values: a lower bound and an upper bound. The lower bound and upper bound simply specify an interval of allowable acceleration. Note that a negative value of acceleration implies deceleration, i.e. braking. Output data destination These three ranges (in ad::rss::world::AccelerationRestriction ) are provided to the system that calls the RSS top-level routine, and indicate the range of acceleration that the AD system must ultimately achieve within its respective lane in order to comply to RSS. In other words, if the AD system seeks to comply to the RSS model, it must achieve an acceleration that is within these bounds provided by the RSS function. Typically, the system would provide the RSS acceleration restriction data to the actuation and control subsystem of the autonomous driving system. This subsystem, external to the RSS library, should enforce the lower and upper bounds of lateral and longitudinal acceleration in respect to the lane provided by the RSS function. Implementation of this process is external to the RSS library, and the system integrator must ensure that this is implemented properly and that RSS output values are used correctly. Bounds on the output data values As discussed above, the output values of the RSS function are lower and upper bounds on acceleration. The lower and upper bounds determined by the RSS function originate from the input provided to the RSS function. Namely, acceleration values are provided as dynamics properties of each vehicle acting as road agent/object in the situation. Hence, in the current implementation, the set of possible output data values is a very small set of values that are provided as input. The output values can be further bounded within absolute lower and upper limits by bounding the input values within those desired limits. Also check the Doxygen documentation of the withinValidInputRange() functions of the respective data types for the actual values defined. It is the responsibility of the system external to the RSS library to ensure that the acceleration and deceleration actually achieved by the vehicle always remain within the limits calculated by the RSS function, and remain within other limits unrelated to RSS (e.g. physical limits imposed by the vehicle dynamics and the environment). Bounds on the output data size The output data of the RSS calculations is a fixed sized structure. As such, the size of the output data is strictly bounded already. It is the responsibility of the system integrator to determine an appropriate rate or maximum rate at which to invoke the RSS library function. RSS library code validation \u00b6 Dependencies The RSS library has no dependency on any external library (except for the C++ Standard Library and the logging library). Coding standards Code quality has been ensured through unit testing. Unit testing achieved code coverage can be retrieved via github deployment . Compiler and compiler security flags The development platforms are Ubuntu Linux 20.04 Focal Fossa and 22.04 Jammy Jellyfish. A standard cmake toolchain has been used to compile the library. Other supported compilers are listed at the main page The following, strict, compilation flags are used: C++14, -Werror, -Wall, -Wextra, -pedantic, -Wconversion, -Wsign-conversion, -Wfloat-equal -Wshadow -Wswitch-default -Wenum-compare -Wformat -Wformat-security. -Werror turns all warnings into errors -Wall enables many warnings about code constructs that are questionable -Wextra enables additional warnings not enabled by -Wall -Wconversion warns for implicit conversions (e.g. between integer and real types) -Wsign-conversion warn for implicit conversions that may alter a value -pedantic issues all warnings demanded by strict ISO C and C++ -Wfloat-equal warn if floating-point values are used in equality comparisons -Wshadow warn on shadowed variable declarations -Wswitch-default warn if the default case is missing in a switch -Wenum-compare warn about a comparison between values of different enumerated types -Wformat* warns about errors within format strings In addition, there are hardening compiler flags * -fstack-protector-all -fasynchronous-unwind-tables -fno-omit-frame-pointer -fno-delete-null-pointer-checks -fno-strict-overflow -fwrapv -fPIE -fPIC -D_FORTIFY_SOURCE=2 and linker flags * -Wl,-z,now -Wl,-z,relro -pie defined to harden the resulting binaries. Hardening is disabled by default, as build hardening is usually injected by the surrounding build system. Compilation with these flags completes without any error or warning. Code analysis The code analysis tool cppcheck was run on the library code, and no relevant issues found. Critical assets The library does not contain critical assets from a security perspective, other than the library code itself.","title":"Security"},{"location":"ad_rss/HLD-Security/#design-for-security","text":"This chapter discusses security aspects.","title":"Design for Security"},{"location":"ad_rss/HLD-Security/#architecture-and-dataflow","text":"As a reminder of the high-level architecture, we refer to two figures from the integration chapter . The RSS Subsystem within the autonomous driving (AD) system has a single input called rssWorldModelData , and outputs called rssProperResponse and rssAccelerationRestrictions . The section decribes further details of the RSS function including the internal calculation steps and internal dataflow. In addition, we refer to the C++ software class ad::rss::core::RssCheck that implements the external RSS interface. The top-level external interface is implemented using a single routine, called calculateAccelerationRestriction() , which is a member function of the RssCheck class. This routine has a single input, called worldModel (of type ad::rss::world::WorldModel , and a single output, called accelerationRestriction of type ad::rss::world::AccelerationRestriction . The library is single-thread, does not make network connections, and does not make connections with other processes remote or local. The library does not make use of any 3rd party components besides logging capabilities, and as such does not have additional security dependencies. The primary adversary model is one where invalid/incorrect input data could be provided to the library input interface by the system or from an upstream source. In the following sections, we discuss security aspects related to: input data (implemented by ad::rss::world::WorldModel ), output data (implemented by ad::rss::world::AccelerationRestrictions ), and the RSS function itself (implemented by ad::rss::core::RssCheck ` and supporting library classes).","title":"Architecture and dataflow"},{"location":"ad_rss/HLD-Security/#rss-input-data-adrssworldworldmodel","text":"","title":"RSS input data (ad::rss::world::WorldModel)"},{"location":"ad_rss/HLD-Security/#rss-output-data-adrssworldaccelerationrestriction","text":"ad::rss::core::RssCheck::calculateAccelerationRestriction() outputs a structure of type ad::rss::world::AccelerationRestriction . This is a very small structure that contains three ranges of acceleration allowed by RSS: allowable range of longitudinal acceleration, allowable range of lateral acceleration to the left of the vehicle, and allowable range of lateral acceleration to the right of the vehicle. Each acceleration range consists of two values: a lower bound and an upper bound. The lower bound and upper bound simply specify an interval of allowable acceleration. Note that a negative value of acceleration implies deceleration, i.e. braking.","title":"RSS output data (ad::rss::world::AccelerationRestriction)"},{"location":"ad_rss/HLD-Security/#rss-library-code-validation","text":"","title":"RSS library code validation"},{"location":"ad_rss/Overview/","text":"Overview Introduction \u00b6 The Responsibility-Sensitive Safety (RSS) model is designed to formalize and contextualize human judgment regarding all multi-agent driving situations and dilemmas. RSS formalizes terms like dangerous situations, proper response and notion of blame in a mathematical way. From planning and decision-making perspective, RSS ensures that the AD system will not issue a command that would lead to an accident. RSS Summary \u00b6 RSS as described here , can be summarized as follows: RSS continuously monitors the current state of the environment, in order to determine if the ego vehicle is currently in a safe state. If the ego vehicle is not in a safe state, RSS will provide a response action that will bring the car back into a safe state. As a result, in case of an accident, the ego vehicle cannot be blamed responsible, as it was not causing the collision. A state is regarded as safe , if the ego vehicle is not causing a collision with another object, under the worst case assumption that the ego vehicle will accelerate (depending on the situation this can be also a deceleration) at maximum possible speed during its response time. Hence, RSS does not take the output of the driving policy into account. However, as RSS uses worst case assumption on reaction time, acceleration etc., it is guaranteed that, no valid action of the driving policy can bring the vehicle into an unsafe state, if RSS regards the current situation as safe. If the ego vehicle is in a dangerous situation, RSS will assure a proper reaction, that will bring the car back into a safe state. Therefore, it will impose proper restrictions for the longitudinal and lateral accelerations of the driving command, that is send to the ego vehicle. Note that this will assure that the vehicle reacts correctly, but the driving policy still has the chance to solve the dangerous situation on a more elaborate way, as long as the desired action is within the RSS limits. The reason is that RSS has only basic information about the environment, whereas the driving policy can use much more information, and is able to perform much more sophisticated path finding strategies. RSS differentiates between longitudinal and lateral conflicts. A longitudinal conflict means that the distance between the ego vehicle and an object in front or in the back of the ego vehicle is smaller than the longitudinal safety distance. Similarly, a lateral conflict arises, if the distance to the left or right of the ego vehicle to another object is less than the required lateral safety margin. Depending on the type of conflict, RSS requires a different response. In addition, RSS differentiates between normal (single- or multi-lane) roads, intersections and unstructured roads (e.g. parking areas). Depending on the type of road, the required response for a conflict is different. Objects are classified into Vulnerable Road Users (e.g. pedestrians) and other (dynamic) traffic objects. The reason for this separation is that the first object group requires special safety considerations, as for example pedestrians may have unknown routes, compared to vehicles. RSS is not about: How to get \"good enough\" sensor data. It is about the usage, which may impose some sensor requirements. Avoiding collisions, if other traffic participants show a completely erratic driving behavior. Instead, it is about ensuring that the ego vehicle cannot be blamed for the accident. Purpose and Scope of this Library \u00b6 The design of the library at hand is based on the academic paper \"On a Formal Model of Safe and Scalable Self-driving Cars\" . The library provides a C++ implementation of RSS according to the aforementioned summary. The key component of this implementation is called \"ad-rss-lib\" . This library receives (post-processed) sensor information and provides actuator command restrictions as output. ad-rss-lib (implemented in the library) and its interfaces to the outside world In summary, the ad-rss-lib receives an object list, with information about all objects in the surrounding environment of the ego vehicle. Then, the ad-rss-lib creates an object - ego vehicle pair, for each object. This pair is usually referred to as \"Situation\" . For all situations, the aforementioned RSS checks are performed and a proper response is calculated. Finally, one overall response is computed by the ad-rss-lib, and the corresponding actuator command restrictions (i.e. lateral and longitudinal acceleration restrictions) are sent out. Note The conversion from sensor data to the object list required by the ad-rss-lib, as well as the conversion of the actuator command restrictions to real driving commands, have to be implemented by the user of this library, as these parts heavily depend on the actual vehicle setup. Note The current scope of the provided implementation is: Standalone C++-library containing the implementation of the ad-rss-lib The ad-rss-lib covers multi-lane roads and intersections Code quality is assured by automated testing with test coverage of 100% on methods and 80% on branches as well as static code analysis The library is intended for the research community.","title":"Overview"},{"location":"ad_rss/Overview/#introduction","text":"The Responsibility-Sensitive Safety (RSS) model is designed to formalize and contextualize human judgment regarding all multi-agent driving situations and dilemmas. RSS formalizes terms like dangerous situations, proper response and notion of blame in a mathematical way. From planning and decision-making perspective, RSS ensures that the AD system will not issue a command that would lead to an accident.","title":"Introduction"},{"location":"ad_rss/Overview/#rss-summary","text":"RSS as described here , can be summarized as follows: RSS continuously monitors the current state of the environment, in order to determine if the ego vehicle is currently in a safe state. If the ego vehicle is not in a safe state, RSS will provide a response action that will bring the car back into a safe state. As a result, in case of an accident, the ego vehicle cannot be blamed responsible, as it was not causing the collision. A state is regarded as safe , if the ego vehicle is not causing a collision with another object, under the worst case assumption that the ego vehicle will accelerate (depending on the situation this can be also a deceleration) at maximum possible speed during its response time. Hence, RSS does not take the output of the driving policy into account. However, as RSS uses worst case assumption on reaction time, acceleration etc., it is guaranteed that, no valid action of the driving policy can bring the vehicle into an unsafe state, if RSS regards the current situation as safe. If the ego vehicle is in a dangerous situation, RSS will assure a proper reaction, that will bring the car back into a safe state. Therefore, it will impose proper restrictions for the longitudinal and lateral accelerations of the driving command, that is send to the ego vehicle. Note that this will assure that the vehicle reacts correctly, but the driving policy still has the chance to solve the dangerous situation on a more elaborate way, as long as the desired action is within the RSS limits. The reason is that RSS has only basic information about the environment, whereas the driving policy can use much more information, and is able to perform much more sophisticated path finding strategies. RSS differentiates between longitudinal and lateral conflicts. A longitudinal conflict means that the distance between the ego vehicle and an object in front or in the back of the ego vehicle is smaller than the longitudinal safety distance. Similarly, a lateral conflict arises, if the distance to the left or right of the ego vehicle to another object is less than the required lateral safety margin. Depending on the type of conflict, RSS requires a different response. In addition, RSS differentiates between normal (single- or multi-lane) roads, intersections and unstructured roads (e.g. parking areas). Depending on the type of road, the required response for a conflict is different. Objects are classified into Vulnerable Road Users (e.g. pedestrians) and other (dynamic) traffic objects. The reason for this separation is that the first object group requires special safety considerations, as for example pedestrians may have unknown routes, compared to vehicles. RSS is not about: How to get \"good enough\" sensor data. It is about the usage, which may impose some sensor requirements. Avoiding collisions, if other traffic participants show a completely erratic driving behavior. Instead, it is about ensuring that the ego vehicle cannot be blamed for the accident.","title":"RSS Summary"},{"location":"ad_rss/Overview/#purpose-and-scope-of-this-library","text":"The design of the library at hand is based on the academic paper \"On a Formal Model of Safe and Scalable Self-driving Cars\" . The library provides a C++ implementation of RSS according to the aforementioned summary. The key component of this implementation is called \"ad-rss-lib\" . This library receives (post-processed) sensor information and provides actuator command restrictions as output. ad-rss-lib (implemented in the library) and its interfaces to the outside world In summary, the ad-rss-lib receives an object list, with information about all objects in the surrounding environment of the ego vehicle. Then, the ad-rss-lib creates an object - ego vehicle pair, for each object. This pair is usually referred to as \"Situation\" . For all situations, the aforementioned RSS checks are performed and a proper response is calculated. Finally, one overall response is computed by the ad-rss-lib, and the corresponding actuator command restrictions (i.e. lateral and longitudinal acceleration restrictions) are sent out. Note The conversion from sensor data to the object list required by the ad-rss-lib, as well as the conversion of the actuator command restrictions to real driving commands, have to be implemented by the user of this library, as these parts heavily depend on the actual vehicle setup. Note The current scope of the provided implementation is: Standalone C++-library containing the implementation of the ad-rss-lib The ad-rss-lib covers multi-lane roads and intersections Code quality is assured by automated testing with test coverage of 100% on methods and 80% on branches as well as static code analysis The library is intended for the research community.","title":"Purpose and Scope of this Library"},{"location":"ad_rss/SupportedRssFeatures/","text":"Release 4.x \u00b6 The release version 4.x extends the core features by unstructured constellation calculation. Release 3.x \u00b6 The release versions 3.x do not extend the core features. Only some interface changes were applied to support the integration with CARLA Driving Simulator . Release 2.x \u00b6 The release versions 2.x extend the core features only to support speed limits . Furthermore some interface changes were applied to support the integration with AD map data . Release 1.x \u00b6 The release versions 1.x cover the complete feature set of RSS as described here , except: Compensating for improper behavior of others Lateral conflicts in case of intersections Respecting occlusions Checks with Vulnerable Road Users Checks for unstructured roads, e.g. parking spaces","title":"Supported RSS Features"},{"location":"ad_rss/SupportedRssFeatures/#release-4x","text":"The release version 4.x extends the core features by unstructured constellation calculation.","title":"Release 4.x"},{"location":"ad_rss/SupportedRssFeatures/#release-3x","text":"The release versions 3.x do not extend the core features. Only some interface changes were applied to support the integration with CARLA Driving Simulator .","title":"Release 3.x"},{"location":"ad_rss/SupportedRssFeatures/#release-2x","text":"The release versions 2.x extend the core features only to support speed limits . Furthermore some interface changes were applied to support the integration with AD map data .","title":"Release 2.x"},{"location":"ad_rss/SupportedRssFeatures/#release-1x","text":"The release versions 1.x cover the complete feature set of RSS as described here , except: Compensating for improper behavior of others Lateral conflicts in case of intersections Respecting occlusions Checks with Vulnerable Road Users Checks for unstructured roads, e.g. parking spaces","title":"Release 1.x"},{"location":"ad_rss/UnstructuredConstellations/","text":"Overview \u00b6 Unstructured constellations implement unstructured roads (described in chapter 3.7.2 of the RSS paper , definitions 19-22) and pedestrians (described in chapter 3.8). In contrast to the structured constellations, two dimensional trajectories with lateral and longitudinal component are calculated. World Modeling \u00b6 To allow customization, every constellations within the ad::rss::world::WorldModel can be calculated as unstructured, depending on the situationType . Behavior Model/Trajectory Set Calculation \u00b6 To calculate a trajectory set, the maximum/minimum values for both, longitudinal and lateral component are applied. The longitudinal boundaries of a trajectory set are defined by the minimum/maximum accelerations, the lateral by the maximum heading change to the left and right. Side Longitudinal Lateral Front max acceleration max left .. max right Back max braking max left .. max right Left max braking .. max acceleration max left Right max braking .. max acceleration max right Each combination is used to calculate a final trajectory point (i.e. a position and a heading). Ranges are sampled. Afterwards the vehicle dimensions are applied and a border polygon is calculated which defines the trajectory set. Important The current implementation uses simplifications that might not calculate valid trajectory sets for certain parameters. There are two relevant trajectory sets: for braking T(C_{b}) T(C_{b}) and continue-forward T(C_{f}) T(C_{f}) . The difference is the longitudinal acceleration after response time: \\alpha_{\\rho,min} \\alpha_{\\rho,min} \\alpha_{\\rho,max} \\alpha_{\\rho,max} T(C_{b}) T(C_{b}) \\alpha_{brake,max} \\alpha_{brake,max} \\alpha_{brake,min} \\alpha_{brake,min} T(C_{f}) T(C_{f}) \\alpha_{brake,max} \\alpha_{brake,max} \\alpha_{accel,max} \\alpha_{accel,max} This is similar for all traffic participants and uses the same rss formulas as in the structured case. The lateral change is depending on the type of traffic participant, as described below. Example trajectory sets for car and pedestrian (red: brake-, green: continue-forward-trajectory) There are two different behavior models, for vehicles and pedestrians. Vehicle The change of the yaw rate h'(t) h'(t) is limited: The maximum change of the yaw rate until response time can be specified by UnstructuredSettings::vehicleYawRateChange . The radius of the circle, the vehicle is driving on is r(t) = v(t)/h'(t) r(t) = v(t)/h'(t) At emergency, after the response time, the vehicle continues driving on a circle (i.e. no further yaw rate change) The minimum radius UnstructuredSettings::vehicleMinRadius defines the minimal radius a vehicle is able to drive on The calculation is done in three steps. Calculate the possible vehicle states and locations at response time Calculate the final vehicle state and location for brake and continueForward Create the corresponding trajectory set polygons In the first step, the vehicle state at response time is calculated by using time increments, specified by UnstructuredSettings::vehicleTrajectoryCalculationStep . (This might lead to an increasing error the farer the point is). The amount of states can be customized by several parameters: UnstructuredSettings::vehicleBackIntermediateYawRateChangeRatioSteps specifies how many steps beside maximum yaw rate change to the left/right and no change at all should be calculated. The value is specifying the steps on one side, therefore the resulting intermediate steps are twice this value. This value is used for the back of the trajectory set. UnstructuredSettings::vehicleFrontIntermediateYawRateChangeRatioSteps similar to above, but for the front of the trajectory set. In the second step, the final vehicle state is calculated for each of the response-time vehicle states by using the corresponding acceleration driven on a circle. The following parameters can be specified: UnstructuredSettings::vehicleContinueForwardIntermediateAccelerationSteps specifies the intermediate acceleration steps (between brakeMin and accelMax) used while calculating the continue forward trajectory set. UnstructuredSettings::vehicleBrakeIntermediateAccelerationSteps specifies the intermediate acceleration steps (between brakeMax and brakeMin) used while calculating the brake trajectory set. UnstructuredSettings::vehicleContinueForwardIntermediateYawRateChangeRatioSteps specifies the intermediate yaw rate change ratio steps used while calculating the continue forward trajectory set. In the third step the final trajectory sets are calculated. To reach an acceptable calculation time some simplification are applied. Keep in mind, that this might cause invalid responses! For each value of acceleration a final state is calculated. This contains of at least three vehicles states: two with maximum yaw rate change to left and right and one with no yaw rate change. For the back and front of the trajectory set there might also be intermediate values for the yaw rate change. For the front a convex hull of all states (including vehicle dimensions) is calculated. For the ones defining the sides of the trajectory set (where only max left/right and center vehicle state are available) a polygon is calculated by merging the convex hull of left+center and right+center. To create the trajectory set all polygons are merged together, including polygons for the linear estimation between the steps. Pedestrian The change of heading |h'(t)| |h'(t)| is limited. That means, the maximum trajectory is defined by a circle until response time. The radius of this circle can be specified by UnstructuredSettings::pedestrianTurningRadius . At emergency, after the response time, the pedestrian will continue at a straight line If the pedestrian is standing, we assign it to all possible lines originating from his current position. Similar to the vehicle calculations the following settings can be used to improve the precision of the polygons: UnstructuredSettings::pedestrianContinueForwardIntermediateHeadingChangeRatioSteps specifies the intermediate heading change ratio steps used while calculating the continue forward trajectory set. UnstructuredSettings::pedestrianContinueForwardIntermediateAccelerationSteps specifies the intermediate steps used while calculating the continue forward trajectory set. (As the pedestrian at max moves on a circle, this value specifies how many points on the circle arc are used) UnstructuredSettings::pedestrianBrakeIntermediateAccelerationSteps specifies the intermediate steps used while calculating the brake trajectory set. UnstructuredSettings::pedestrianFrontIntermediateHeadingChangeRatioSteps specifies the intermediate steps that are used. The value is specifying the steps on one side, therefore the resulting intermediate steps are twice this value. This value is used for the front of the trajectory set. UnstructuredSettings::pedestrianBackIntermediateHeadingChangeRatioSteps specifies the intermediate steps that are used. The value is specifying the steps on one side, therefore the resulting intermediate steps are twice this value. This value is used for the front of the trajectory set. Decision making \u00b6 The RSS paper definition 22 states conditions, that are relevant to calculate if a constellation is dangerous and how to behave then. Depending on their values, three decisions are possible: brake : Longitudinal braking continue forward : Continue driving without limitations drive away : Drive away within a certain heading range The conditions are based on the brake and continue-forward trajectory sets for the ego vehicle and another traffic participant. Condition 22.1 a.) T_{ego, brake} \\cap T_{other, forward} = 0 T_{ego, brake} \\cap T_{other, forward} = 0 and T_{other, brake} \\cap T_{ego, forward} \\ne 0 T_{other, brake} \\cap T_{ego, forward} \\ne 0 b.) T_{other, brake} \\cap T_{ego, forward} = 0 T_{other, brake} \\cap T_{ego, forward} = 0 and T_{ego, brake} \\cap T_{other, forward} \\ne 0 T_{ego, brake} \\cap T_{other, forward} \\ne 0 Condition 22.2 T_{ego, brake} \\cap T_{other, brake} = 0 T_{ego, brake} \\cap T_{other, brake} = 0 The following diagram describes the decision making. Decision making The condition 22.1.b at the last safe point in time might lead to the behavior \"Continue Forward\" although the constellation is dangerous. The reason is, that the conditions 22.1 define, which traffic participant has to brake and which one can continue. Response \u00b6 Continue Forward If the result is continue_forward no acceleration restrictions are applied. Brake If the result is brake , the longitudinal acceleration restriction is set to alphaLon.brakeMin of the state. Driving away In certain situations the ego vehicle might be allowed to drive away from a dangerous constellation using a given heading range. The heading range is calculated using the position vectors of the traffic participants and the velocity vector of the ego. The angle between \\tau_{ego}(t) \u2212 \\tau_{other}(t) \\tau_{ego}(t) \u2212 \\tau_{other}(t) and \\tau'_{ego}(t) \\tau'_{ego}(t) needs to be \\le \\theta \\le \\theta \\theta \\theta can be specified by UnstructuredSettings::driveAwayMaxAngle As multiple constellations might allow different ranges to drive away, the ad::rss::state::ProperResponse provides a vector of headingRanges . Together with the steering range of the vehicle the allowed heading range can be calculated. Allowed heading ranges in blue If multiple states result in drive_away , but no headingRange overlap is available the state is escalated to brake . The drive_away mode remains active as long as: The ego vehicle moves with a steering angle that is within the allowed heading range The other vehicle doesn't move","title":"Unstructured Constellations"},{"location":"ad_rss/UnstructuredConstellations/#overview","text":"Unstructured constellations implement unstructured roads (described in chapter 3.7.2 of the RSS paper , definitions 19-22) and pedestrians (described in chapter 3.8). In contrast to the structured constellations, two dimensional trajectories with lateral and longitudinal component are calculated.","title":"Overview"},{"location":"ad_rss/UnstructuredConstellations/#world-modeling","text":"To allow customization, every constellations within the ad::rss::world::WorldModel can be calculated as unstructured, depending on the situationType .","title":"World Modeling"},{"location":"ad_rss/UnstructuredConstellations/#behavior-modeltrajectory-set-calculation","text":"To calculate a trajectory set, the maximum/minimum values for both, longitudinal and lateral component are applied. The longitudinal boundaries of a trajectory set are defined by the minimum/maximum accelerations, the lateral by the maximum heading change to the left and right. Side Longitudinal Lateral Front max acceleration max left .. max right Back max braking max left .. max right Left max braking .. max acceleration max left Right max braking .. max acceleration max right Each combination is used to calculate a final trajectory point (i.e. a position and a heading). Ranges are sampled. Afterwards the vehicle dimensions are applied and a border polygon is calculated which defines the trajectory set. Important The current implementation uses simplifications that might not calculate valid trajectory sets for certain parameters. There are two relevant trajectory sets: for braking T(C_{b}) T(C_{b}) and continue-forward T(C_{f}) T(C_{f}) . The difference is the longitudinal acceleration after response time: \\alpha_{\\rho,min} \\alpha_{\\rho,min} \\alpha_{\\rho,max} \\alpha_{\\rho,max} T(C_{b}) T(C_{b}) \\alpha_{brake,max} \\alpha_{brake,max} \\alpha_{brake,min} \\alpha_{brake,min} T(C_{f}) T(C_{f}) \\alpha_{brake,max} \\alpha_{brake,max} \\alpha_{accel,max} \\alpha_{accel,max} This is similar for all traffic participants and uses the same rss formulas as in the structured case. The lateral change is depending on the type of traffic participant, as described below. Example trajectory sets for car and pedestrian (red: brake-, green: continue-forward-trajectory) There are two different behavior models, for vehicles and pedestrians.","title":"Behavior Model/Trajectory Set Calculation"},{"location":"ad_rss/UnstructuredConstellations/#decision-making","text":"The RSS paper definition 22 states conditions, that are relevant to calculate if a constellation is dangerous and how to behave then. Depending on their values, three decisions are possible: brake : Longitudinal braking continue forward : Continue driving without limitations drive away : Drive away within a certain heading range The conditions are based on the brake and continue-forward trajectory sets for the ego vehicle and another traffic participant. Condition 22.1 a.) T_{ego, brake} \\cap T_{other, forward} = 0 T_{ego, brake} \\cap T_{other, forward} = 0 and T_{other, brake} \\cap T_{ego, forward} \\ne 0 T_{other, brake} \\cap T_{ego, forward} \\ne 0 b.) T_{other, brake} \\cap T_{ego, forward} = 0 T_{other, brake} \\cap T_{ego, forward} = 0 and T_{ego, brake} \\cap T_{other, forward} \\ne 0 T_{ego, brake} \\cap T_{other, forward} \\ne 0 Condition 22.2 T_{ego, brake} \\cap T_{other, brake} = 0 T_{ego, brake} \\cap T_{other, brake} = 0 The following diagram describes the decision making. Decision making The condition 22.1.b at the last safe point in time might lead to the behavior \"Continue Forward\" although the constellation is dangerous. The reason is, that the conditions 22.1 define, which traffic participant has to brake and which one can continue.","title":"Decision making"},{"location":"ad_rss/UnstructuredConstellations/#response","text":"","title":"Response"},{"location":"ad_rss/ad_rss_python/","text":"Usage of python binding for ad_rss Compilation of ad_rss_python (build option -DBUILD_PYTHON_BINDING=ON ) will create an ad_rss python package inside the install/ad_rss/lib/pythonMaj.Min/site-packages folder. The packages can be used inside any python code to use datatypes or call methods defined in ad_rss and its dependency ad_physics. Usage of python binding \u00b6 To use the compiled python binding, one has to extend the current environment to be able to use the newly created packages. Afterwards, one can import the python package and use it as any other python module. ad-rss-lib$> echo \"Setting PYTHONPATH and LD_LIBRARY_PATH:\" ad-rss-lib$> source install/setup.bash ad-rss-lib$> python3.8 >>> import ad_rss as ad >>> world_model = ad.rss.world.WorldModel() >>> print(world_model) Also the interface of the dependency can be accessed directly, since ad_rss is relying on those: >>> distance = ad.physics.Distance(2.0) >>> print(distance) For some simple examples, you might also want to spot into the ad_rss/python/tests folder.","title":"Core Library"},{"location":"ad_rss/ad_rss_python/#usage-of-python-binding","text":"To use the compiled python binding, one has to extend the current environment to be able to use the newly created packages. Afterwards, one can import the python package and use it as any other python module. ad-rss-lib$> echo \"Setting PYTHONPATH and LD_LIBRARY_PATH:\" ad-rss-lib$> source install/setup.bash ad-rss-lib$> python3.8 >>> import ad_rss as ad >>> world_model = ad.rss.world.WorldModel() >>> print(world_model) Also the interface of the dependency can be accessed directly, since ad_rss is relying on those: >>> distance = ad.physics.Distance(2.0) >>> print(distance) For some simple examples, you might also want to spot into the ad_rss/python/tests folder.","title":"Usage of python binding"},{"location":"ad_rss_map_integration/ConstructRSSScenes/","text":"Construction of the RSS Scenes between two vehicles The RSS core implementation ( ad_rss ) proposes a situation based coordinate system to perform the RSS calculations between two vehicles. This library provides an exemplary implementation on how a real-world situation can be transformed into such coordinate system. Note This implementation considers neither all possible road network layouts nor all configurations between two vehicles that may happen. In reality, many corner-cases have to be considered to cover all of that (e.g. a backward driving car). Table of contents Construct situations Construct Road Area Convert Vehicle Data Consider Speed Limits Construction of the individual situations \u00b6 In general, the real world road network is far more complex than just one straight road: the situation between two vehicles is not necessarily unambiguous, especially as the vehicles can take different routes through intersections. Therefore, the worst-case has to be covered here, too. All potential configurations have to be considered when performing the situation analysis and creating the respective Situation Based Coordinate System. As a result of this there might be multiple situations at the same time to be considered between two vehicles. Before the actual road area of the vehicles can be calculated, the type of situation has to be determined, which is performed within ad::rss::map::RssSceneCreation::appendScenes() as follows: Calculate the connecting route Based on road network data, the vehicle position and the object position, the shortest connecting route between these two is calculated ( ad::map::route::planning::calculateConnectingRoute() ). To cover also opposite direction and intersection use-cases, the nominal driving direction on the lanes is disregarded when the connecting route is calculated. Furthermore, as the map matched positions of vehicle and object might span over multiple lanes, all possible combinations are taken into account. Decide on the kind of situation: same direction, opposite direction or intersection If both vehicles are driving in the same direction with respect to the connecting route a same direction situation is created. This is done, regardless if there are intersections between the two vehicles present, because one vehicle just follows the other, potentially through the intersection. One vehicle is following the other on the same road by driving in the same direction: either on the same lane or on another parallel lane If both vehicles drive in opposite direction and there is no intersection in between an opposite direction situation is created. Both vehicle are approaching each other on the same road by driving in the opposite direction: either on the same lane or on another parallel lane Otherwise, the potential future routes of the vehicles have to be calculated and combined with each other. As in an AD vehicle the ego route usually is known that route is taken as basis for the ego vehicle, if present. Every intersection present in both routes of these combinations might result in a new situation to be considered: Besides classical X-intersection or T-intersections also areas where lanes vanish and a lateral conflict is unavoidable have to be treated as intersection cases. If both drive through the intersection coming from different intersection arms without crossing routes, the vehicles pass each other and an opposite direction situation is created Else, the routes within the intersection are crossing each other and an intersection situation is created. To decide which of the vehicles has priority within the intersection the capabilities of the class ad::map::intersection::Intersection() are used. In case of traffic light intersections, the kind and status of the relevant traffic light determines the current priorities. Handling of similar situations The consideration of intersections with all the possible routes leads to an increase in the number of situations. Therefore, to reduce the computational effort of the actual safety analysis, within the ad_rss core implementation situations that represent the same scene are merged if they describe the 'same' situation (i.e. the same route through the intersection). To achieve this, and still be able to keep the worst case assessment, the distances to enter/leave the intersection both are intervals to provide the minimum and maximum observed distance to enter and leave the respective intersection. Steps to create the situations required for safety calculations having the road network as well as the object data available as input Construction of the situation specific Road Area \u00b6 RSS incorporates the changes in the road geometries as minimum/maximum length and width parameters of the respective lane segments into the worst-case consideration of positions and distances. This makes the vehicle behaving over cautious if the road sections taken into account are selected unnecessarily large: the more the differences in minimal/maximal width or length of these segments are the more conservative the behavior of the vehicle gets. Therefore, the road area for the creation of the situation is restricted to the direct surrounding of the two vehicles, which is represented by the connecting route as described in the last section for non-intersection situation. Construction of a same direction Road Area as basis for the Situation-Based Coordinate System: The red area consists of all lane segments along the road relevant for the situation between the two vehicles Nevertheless, the nominal driving direction of the lane segments in respect to the direction of the road area have to be preserved to allow RSS to decide if a vehicle is driving in wrong direction. The direction of the road area is determined by the driving direction of the vehicles. In opposite direction use-case, where both vehicles are approaching each other, the direction is determined by the driving direction of the ego-vehicle In intersection situations, both vehicles approach from different roads. Therefore, two road areas have to be taken into account which end in an overlapping area at the intersection. Construction of the situation specific Road Area in case of an intersection: Each vehicle gets its own road area. The lane segments within the intersection are marked as such. Be aware: The lane segment type intersection is only provided for lane segments of the intersection under consideration within the current situation. Conversion of the vehicle data in respect to the Road Area \u00b6 Having the situations and the respective Road Area(s) constructed, the vehicle data has to be converted into the desired RSS object format ad::rss::world::Object . The main aspects of this are the conversion of the velocity and of the bounding box. Conversion of the vehicle velocity within the road area Example road area for velocity conversion To convert the velocity of a vehicle within the situation, one can take the center point of the vehicle and the vehicle orientation in respect to the road area driving direction as basis to split the vehicle speed into its lateral and longitudinal components in respect to the borders of the road area. Having a detailed look at the left vehicle within the above sketched scene. Let it drive with 10m/s in parallel to the lanes. The split of the velocity leads to longitudinal velocity component of v_{lon} = 10 m/s v_{lon} = 10 m/s and a lateral velocity component of v_{lat} = 0 m/s v_{lat} = 0 m/s . Vehicle velocity conversion on straight lanes This becomes different, when the lane is not straight anymore. When driving with 20\\circ 20\\circ in respect to the lane at the center point. For the center point one gets a longitudinal velocity component of v_{lon} = \\cos(20\\circ) * 10 m/s = 9.4 m/s v_{lon} = \\cos(20\\circ) * 10 m/s = 9.4 m/s and a lateral velocity component of v_{lat} = \\sin(20\\circ) * 10 m/s = 3.4 m/s v_{lat} = \\sin(20\\circ) * 10 m/s = 3.4 m/s . Vehicle velocity conversion in curves Construction of the situation based bounding box of the vehicles within the road area Based on the Road Area, the individual bounding box of the vehicles are calculated. Road Area with lane Ids assigned For this, the ad::map::match::LaneOccupiedRegionList with the occupied regions calculated on basis of the real lane geometries (see ad_map_access for reference) is transformed into the ad::rss:world::OccupiedRegionVector mainly by: consider only lanes present in the Road Area adapt the parametric range in respect to the driving direction of the lane segment within the Road Area Example occupied regions for two vehicles within a Road Area On the one hand side this step is simple in calculation, but because of the representation of the lane segments within the Situation-Based Coordinate System (minimal/maximal width and length) and the use of the situation specific worst-case lateral and longitudinal border values of the vehicles within the RSS calculations, the vehicle bounding boxes are enlarged finally as depicted in the following image: Creation of the situation-based coordinate system: Worst-case transformation of the vehicle bounding box. The metric road on the left leads to transformed vehicles and their bounding boxes (red) on the right, sketched for a narrowing road area at the top and a curve at the bottom. Calculation of Metric distances within the Road Area The minimal (maximal) metric position p^{lon}_{min} p^{lon}_{min} ( p^{lon}_{max} p^{lon}_{max} ) in longitudinal direction of a vehicle within the road area is calculated by taking the sum of all minimal (maximal) metric lengths of all previous road segments, plus the parametric scaled minimal (maximal) length of the first road segment it touches (explained in detail in the subsections below). Like this, the \\Delta \\Delta of every part of the road segment up to the vehicle is finally incorporated into it's metric length within the road area l = p^{lon}_{max} - p^{lon}_{min} l = p^{lon}_{max} - p^{lon}_{min} : The vehicle gets stretched by each of the \\Delta \\Delta . To calculate the longitudinal distance of two vehicles towards each other the maximum position of the vehicle at the back is subtracted from the minimum position of the vehicle in front: d^{lon} = p^{lon}_{front,min} - p^{lon}_{back,max} d^{lon} = p^{lon}_{front,min} - p^{lon}_{back,max} This happens in a similar way in lateral direction and with the distance towards the intersection. Because the ad_rss implementation takes all parts of the road area into account as provided from outside (i.e. does not cut-off the road area before the first car), the \\Delta \\Delta is incorporated as negative component into d^{lon} d^{lon} . The following Figure provides an example: Example: Let the actual distance of the two cars be d^{lon}_{real} = 17\\,m d^{lon}_{real} = 17\\,m . Further let the right border of the road area curve within the intersection be 15\\,m 15\\,m and the outer border be 23\\,m 23\\,m . With the transformation into ad_rss situation based coordinate system the information on the actual road geometry gets lost, so that the difference of the border length of 6\\,m 6\\,m in a road segment at the beginning leads to a decreased metric distance of the two cars of d^{lon}_{RoadArea} = 11\\,m d^{lon}_{RoadArea} = 11\\,m . Cutting the road area after the (red) vehicle in the back would lead to d^{lon}_{RoadArea} = d^{lon}_{real} = 17\\,m d^{lon}_{RoadArea} = d^{lon}_{real} = 17\\,m . To understand the details of why it is important to restrict the road area in its extend, the actual realized calculation of metric bounding box and metric distances within the road area within ad_rss are sketched in the following sections. Metrics of road segments within Road Area The overall metric minima/maxima of the road segment at index r ( RS_{min}^r, RS_{max}^r RS_{min}^r, RS_{max}^r ) is calculated by combination of the minima/maxima ( LS_{min},LS_{max} LS_{min},LS_{max} ) of the contained lane segments: RS_{lon,min}^r = \\min\\limits_{l}\u2061(LS_{lon,min}^{r,l}) RS_{lon,min}^r = \\min\\limits_{l}\u2061(LS_{lon,min}^{r,l}) RS_{lon,max}^r= \\max\\limits_{l}\u2061(LS_{lon,max}^{r,l}) RS_{lon,max}^r= \\max\\limits_{l}\u2061(LS_{lon,max}^{r,l}) RS_{lat,min}^r=0 RS_{lat,min}^r=0 RS_{lat,max}^r= \\sum_{l}LS_{lat,max}^{r,l} RS_{lat,max}^r= \\sum_{l}LS_{lat,max}^{r,l} \u2061 The overall minima/maxima dimensions of the road area ( RA_{min}, RA_{max} RA_{min}, RA_{max} ) are calculated by the combinations of the minima/maxima of the road segments: RA_{lon,min} = \\sum_r RS_{lon,min}^r RA_{lon,min} = \\sum_r RS_{lon,min}^r RA_{lon,max} = \\sum_r RS_{lon,max}^r RA_{lon,max} = \\sum_r RS_{lon,max}^r RA_{lat,min} = \\min\\limits_{r}\u2061 (RS_{lat,min}^r)=0 RA_{lat,min} = \\min\\limits_{r}\u2061 (RS_{lat,min}^r)=0 RA_{lat,max} = \\max\\limits_{r}\u2061 (RS_{lat,max}^r) RA_{lat,max} = \\max\\limits_{r}\u2061 (RS_{lat,max}^r) Metrics bounding box of vehicles within Road Area In a similar manner the vehicle parametric bounding box definitions ( PBB PBB ) can be used to calculate the minimal and maximal metric position in longitudinal direction of the vehicle within of the whole road area: the minimal longitudinal position of a vehicle ( BB_{min}^{lon} BB_{min}^{lon} ) is calculated by taking the sum of all minimal metric lengths of all previous road segments, plus the parametric scaled minimal length of the first road segment it touches. BB_{lon,min} = \\sum_{r=0}^{i-1} RS_{lon,min}^r + \\min\\limits_{l}\u2061 ( PBB_{lon,min}^{i,l} * LS_{lon,min}^{i,l} ) BB_{lon,min} = \\sum_{r=0}^{i-1} RS_{lon,min}^r + \\min\\limits_{l}\u2061 ( PBB_{lon,min}^{i,l} * LS_{lon,min}^{i,l} ) , with i: first road segment the vehicle touches. BB_{lon,max} = \\sum_{r=0}^{i-1} RS_{lon,max}^r + \\max\\limits_{l} ( PBB_{lon,max}^{i,l} * LS_{(lon,max}^{i,l}) BB_{lon,max} = \\sum_{r=0}^{i-1} RS_{lon,max}^r + \\max\\limits_{l} ( PBB_{lon,max}^{i,l} * LS_{(lon,max}^{i,l}) , with i: last road segment the vehicle touches. BB_{lat,min} = \\min\\limits_{r}\u2061 (\\sum_{l=0}^{i-1} LS_{lat,min}^{r,l} + (PBB_{lat,min}^{r,i}* LS_{lat,min}^{r,i}) ) BB_{lat,min} = \\min\\limits_{r}\u2061 (\\sum_{l=0}^{i-1} LS_{lat,min}^{r,l} + (PBB_{lat,min}^{r,i}* LS_{lat,min}^{r,i}) ) , with i: first lane segment within road segment r the vehicle touches. BB_{lat,max} = \\max\\limits_{r}\u2061 (\\sum_{l=0}^{i-1} LS_{lat,max}^{r,l} + (PBB_{lat,max}^{r,i} * LS_{lat,max}^{r,i}) BB_{lat,max} = \\max\\limits_{r}\u2061 (\\sum_{l=0}^{i-1} LS_{lat,max}^{r,l} + (PBB_{lat,max}^{r,i} * LS_{lat,max}^{r,i}) , with i: last lane segment within road segment r the vehicle touches. Metrics distances between vehicles Having the vehicles metric bounding boxes within the road area at hand, it is straight forward to calculate the current longitudinal and lateral distances of the vehicles towards each other. Let A be the upper left vehicle and B the lower right vehicle in the sketched road area above, then the distances are defined by: d_{lon} = BB_{lon,min}^B - BB_{lon,max}^A d_{lon} = BB_{lon,min}^B - BB_{lon,max}^A d_{lat} = BB_{lat,min}^B - BB_{lat,max}^A d_{lat} = BB_{lat,min}^B - BB_{lat,max}^A Metrics distances in respect to the intersection The calculation of the intersection distance of a vehicle can then be performed in the following way: d_{enter} = \\sum_{r=0}^{i-1} RS_{lon,min}^r -BB_{lon,max} d_{enter} = \\sum_{r=0}^{i-1} RS_{lon,min}^r -BB_{lon,max} , with i: first road segment within the intersection. d_{exit} = \\sum_{r=0}^i RS_{lon,max}^r - BB_{lon,min} d_{exit} = \\sum_{r=0}^i RS_{lon,max}^r - BB_{lon,min} , with i: last road segment within the intersection. Having the vehicles metric bounding boxes and the distances to the intersection at hand, it is straight forward to calculate the current longitudinal distance of the vehicles towards each other in respect to the intersection. Let A be the vehicle coming from west and B the vehicle coming from south in the figure above with d_{enter}^A > d_{enter}^B d_{enter}^A > d_{enter}^B , then the distance can be calculated by: d_{lon} = \\max\u2061 (0, d_{enter}^A - d_{enter}^B - (BB_{lon,max}^B -BB_{lon,min}^B)) d_{lon} = \\max\u2061 (0, d_{enter}^A - d_{enter}^B - (BB_{lon,max}^B -BB_{lon,min}^B)) Consider speed limits \u00b6 The RSS paper is assuming reasonable behavior of other traffic participants. By the general RSS formulas, vehicles are allowed to accelerate with maximum possible acceleration within their reaction time. Especially in urban scenarios this can lead to unnecessarily big safety distances if expecting that fast driving vehicles will accelerate even further beyond the speed limits within their reaction time. As it's unreasonable behavior of others to accelerate far beyond the maximum allowed speed, the construction of the scenes with ad::rss::map::RssSceneCreation::appendScenes() supports to select between different modes to consider the speed limit within RSS accelerated movement, by setting the ad::rss::world::RssDynamics dynamics accordingly: None : Do not change the objects maxSpeedOnAcceleration parameter of the RssDynamics ExactSpeedLimit : Set the objects maxSpeedOnAcceleration parameter of the RssDynamics to the maximal allowed speed of the relevant road section IncreasedSpeedLimit5 : Set the objects maxSpeedOnAcceleration parameter of the RssDynamics to the maximal allowed speed of the relevant road section + 5 percent IncreasedSpeedLimit10 : Set the objects maxSpeedOnAcceleration parameter of the RssDynamics to the maximal allowed speed of the relevant road section + 10 percent In general, this extends the scope of the RSS paper, but might be a reasonable change to improve acceptance within society.","title":"Construction of the RSS Scenes"},{"location":"ad_rss_map_integration/ConstructRSSScenes/#construction-of-the-individual-situations","text":"In general, the real world road network is far more complex than just one straight road: the situation between two vehicles is not necessarily unambiguous, especially as the vehicles can take different routes through intersections. Therefore, the worst-case has to be covered here, too. All potential configurations have to be considered when performing the situation analysis and creating the respective Situation Based Coordinate System. As a result of this there might be multiple situations at the same time to be considered between two vehicles. Before the actual road area of the vehicles can be calculated, the type of situation has to be determined, which is performed within ad::rss::map::RssSceneCreation::appendScenes() as follows:","title":"Construction of the individual situations "},{"location":"ad_rss_map_integration/ConstructRSSScenes/#construction-of-the-situation-specific-road-area","text":"RSS incorporates the changes in the road geometries as minimum/maximum length and width parameters of the respective lane segments into the worst-case consideration of positions and distances. This makes the vehicle behaving over cautious if the road sections taken into account are selected unnecessarily large: the more the differences in minimal/maximal width or length of these segments are the more conservative the behavior of the vehicle gets. Therefore, the road area for the creation of the situation is restricted to the direct surrounding of the two vehicles, which is represented by the connecting route as described in the last section for non-intersection situation. Construction of a same direction Road Area as basis for the Situation-Based Coordinate System: The red area consists of all lane segments along the road relevant for the situation between the two vehicles Nevertheless, the nominal driving direction of the lane segments in respect to the direction of the road area have to be preserved to allow RSS to decide if a vehicle is driving in wrong direction. The direction of the road area is determined by the driving direction of the vehicles. In opposite direction use-case, where both vehicles are approaching each other, the direction is determined by the driving direction of the ego-vehicle In intersection situations, both vehicles approach from different roads. Therefore, two road areas have to be taken into account which end in an overlapping area at the intersection. Construction of the situation specific Road Area in case of an intersection: Each vehicle gets its own road area. The lane segments within the intersection are marked as such. Be aware: The lane segment type intersection is only provided for lane segments of the intersection under consideration within the current situation.","title":"Construction of the situation specific Road Area "},{"location":"ad_rss_map_integration/ConstructRSSScenes/#conversion-of-the-vehicle-data-in-respect-to-the-road-area","text":"Having the situations and the respective Road Area(s) constructed, the vehicle data has to be converted into the desired RSS object format ad::rss::world::Object . The main aspects of this are the conversion of the velocity and of the bounding box.","title":"Conversion of the vehicle data in respect to the Road Area  "},{"location":"ad_rss_map_integration/ConstructRSSScenes/#consider-speed-limits","text":"The RSS paper is assuming reasonable behavior of other traffic participants. By the general RSS formulas, vehicles are allowed to accelerate with maximum possible acceleration within their reaction time. Especially in urban scenarios this can lead to unnecessarily big safety distances if expecting that fast driving vehicles will accelerate even further beyond the speed limits within their reaction time. As it's unreasonable behavior of others to accelerate far beyond the maximum allowed speed, the construction of the scenes with ad::rss::map::RssSceneCreation::appendScenes() supports to select between different modes to consider the speed limit within RSS accelerated movement, by setting the ad::rss::world::RssDynamics dynamics accordingly: None : Do not change the objects maxSpeedOnAcceleration parameter of the RssDynamics ExactSpeedLimit : Set the objects maxSpeedOnAcceleration parameter of the RssDynamics to the maximal allowed speed of the relevant road section IncreasedSpeedLimit5 : Set the objects maxSpeedOnAcceleration parameter of the RssDynamics to the maximal allowed speed of the relevant road section + 5 percent IncreasedSpeedLimit10 : Set the objects maxSpeedOnAcceleration parameter of the RssDynamics to the maximal allowed speed of the relevant road section + 10 percent In general, this extends the scope of the RSS paper, but might be a reasonable change to improve acceptance within society.","title":"Consider speed limits "},{"location":"ad_rss_map_integration/HandleRoadBoundaries/","text":"Handling of road boundaries RSS and Evasive maneuvers If you can avoid an accident without causing another accident, you must do it. If a situation becomes dangerous and all vehicles respond properly according to RSS, braking should always result in a safe state. But what happens if others do not obey to the rules of RSS and braking will not prevent from a collision anymore? There might be still a possibility to escape from the dangerous situation. The RSS paper proposes to perform a proper response with evasive effort: perform an maneuver to evade the vehicle from the dangerous situation, respecting acceleration maxima and proper responses to all other traffic agents. RSS only defines behavior of interaction among vehicles and objects. The initial implementation of RSS within ad_rss currently has no notion of drivable freespace area. Hence, it cannot determine that an evasive maneuver -- if initiated by RSS -- will cause an accident with an obstacle or forces the vehicle to leave the road. Stay on road The integration of RSS with map data now opens up the possibility to get a description of the road boundaries. To overcome the issue of leaving the road, virtual objects can be added at the road boundaries. Then, these virtual objects can be handled within ad_rss the same way as any other vehicle/object. Thus, all RSS formulas are applied to these virtual objects, as well. As a result, the vehicle will keep a minimum safe distance to all road boundaries and stays on the drivable road. By adding the left and right border of the drivable road as artificial objects to the RSS scenes, RSS will ensure a safety distance to these virtual 'walls' and though make the vehicle to stay on its road. Virtual road border objects When adding the road boundaries to the list of RSS scenes, there is still the question which borders to actually use. Do we want to restrict the vehicle to it's currently planned route? Do we want to allow the vehicle to be able to enter the opposite lanes where the speed difference towards other cars is expected to be much higher? Do we even want to allow the vehicle to enter non-drivable lanes like shoulder lanes or even pedestrian ways? As these questions may be answered differently in respect to the kind of road, the situation, etc. ad_rss_map_integration allows the user to select between different modes ( ad::rss::map::RssSceneCreation::AppendRoadBoundariesMode ) when calling ad::rss::map::RssSceneCreation::AppendRoadBoundaries() . On the other hand, since the virtual objects are of static nature, the current implementation sets the ad::rss::world::RssDynamics of the road boundary objects to some fixed values: no acceleration, minimal response time, etc. The same is true for the breadth of the road boundaries, which are just fixed to 0.001 of the respective lane segment.","title":"Handling of road boundaries"},{"location":"ad_rss_map_integration/Main/","text":"C++ library for integrating Responsibility Sensitive Safety (RSS) with automated driving maps Table of contents Introduction High Level Design API documentation Python Binding Introduction \u00b6 This ad_rss_map_integration library provides a C++ implementation for integrating Responsibility Sensitive Safety (RSS) with automated driving maps. When RSS is to be integrated into a larger system it is usually up to the user implementation to provide the required input into RSS based on the environment information available within the system. Integration of RSS into an AD system with its general Sense, Plan and Act main components To calculate such input to RSS, the ad::rss::world::WorldModel , usually a-priori knowledge on the environment and especially on map information is required: Given the positions of all of the traffic participants, a map matched position has to be calculated and a combination of route planning and prediction based on the road topology has to be performed. Then, the route connecting the ego-vehicle and the other vehicle has to be analyzed to deduce the kind of RSS-situation between those two: driving on same road in same direction, in opposite direction or being faced with an intersection with respective priority rules. If the kind of situation is derived, the relevant road areas and object/vehicle information have to be transformed into the suitable world model format expected by the \u2018C++ library for RSS\u2019 ( ad_rss ) for further analysis. These steps are not trivial. To enable the community to understand and evaluate RSS further, this library provides an exemplary implementation of these steps. The implementation within this library neither can be seen to be complete, fully correct or final, nor it is claiming to be the only way of doing that. It's rather a piece of software required to perform more thoroughly analysis within a simulation framework like e.g. CARLA driving simulator . This library makes use of the ad_map_access interface to interact with AD map data: read the AD map data from the OpenDRIVE maps provided with CARLA , perform required matching, planning and analysis operations. High Level Design \u00b6 The high level design documentation provides more insights on the architecture and functionality of this library. Construction of the RSS Scenes Handling of road boundaries API documentation \u00b6 Detailed documentation on API level is available via Doxygen documentation within the code. Python Binding \u00b6 There is also a python binding for the ad_map_access library available: ad_rss_map_integration_python","title":"Overview"},{"location":"ad_rss_map_integration/Main/#introduction","text":"This ad_rss_map_integration library provides a C++ implementation for integrating Responsibility Sensitive Safety (RSS) with automated driving maps. When RSS is to be integrated into a larger system it is usually up to the user implementation to provide the required input into RSS based on the environment information available within the system. Integration of RSS into an AD system with its general Sense, Plan and Act main components To calculate such input to RSS, the ad::rss::world::WorldModel , usually a-priori knowledge on the environment and especially on map information is required: Given the positions of all of the traffic participants, a map matched position has to be calculated and a combination of route planning and prediction based on the road topology has to be performed. Then, the route connecting the ego-vehicle and the other vehicle has to be analyzed to deduce the kind of RSS-situation between those two: driving on same road in same direction, in opposite direction or being faced with an intersection with respective priority rules. If the kind of situation is derived, the relevant road areas and object/vehicle information have to be transformed into the suitable world model format expected by the \u2018C++ library for RSS\u2019 ( ad_rss ) for further analysis. These steps are not trivial. To enable the community to understand and evaluate RSS further, this library provides an exemplary implementation of these steps. The implementation within this library neither can be seen to be complete, fully correct or final, nor it is claiming to be the only way of doing that. It's rather a piece of software required to perform more thoroughly analysis within a simulation framework like e.g. CARLA driving simulator . This library makes use of the ad_map_access interface to interact with AD map data: read the AD map data from the OpenDRIVE maps provided with CARLA , perform required matching, planning and analysis operations.","title":"Introduction "},{"location":"ad_rss_map_integration/Main/#high-level-design","text":"The high level design documentation provides more insights on the architecture and functionality of this library. Construction of the RSS Scenes Handling of road boundaries","title":"High Level Design "},{"location":"ad_rss_map_integration/Main/#api-documentation","text":"Detailed documentation on API level is available via Doxygen documentation within the code.","title":"API documentation "},{"location":"ad_rss_map_integration/Main/#python-binding","text":"There is also a python binding for the ad_map_access library available: ad_rss_map_integration_python","title":"Python Binding "},{"location":"ad_rss_map_integration/ad_rss_map_integration_python/","text":"Usage of python binding for ad_rss_map_integration Compilation of ad_rss_map_integration_python (build option -DBUILD_PYTHON_BINDING=ON ) will create an ad_rss_map_integration python package inside the install/ad_rss_map_integration/lib/pythonMaj.Min/site-packages folder. The packages can be used inside any python code to use datatypes or call methods defined in ad_rss_map_integration and its dependencies ad_physics, ad_map_access and ad_rss. Usage of python binding \u00b6 To use the compiled python binding, one has to extend the current environment to be able to use the newly created library. Afterwards, one can import the python package and use it as any other python module. ad-rss-lib$> echo \"Setting PYTHONPATH and LD_LIBRARY_PATH:\" ad-rss-lib$> source install/setup.bash ad-rss-lib$> python3.8 >>> import ad_rss_map_integration as ad >>> scene_creation = ad.rss.map.RssSceneCreation(1, ad.rss.world.RssDynamics()) >>> world_model = scene_creation.getWorldModel() >>> print(world_model) Also the interface of the dependencies can be accessed directly, since ad_rss_map_integration is relying on those (e.g. the type of the above returned world_model is actually ad.rss.world.WorldModel() provided by ad_rss): >>> ad.map.access.init(\"ad_rss_map_integration/python/tests/resources/Town01.txt\") >>> lanes = ad.map.lane.getLanes() >>> print(len(lanes)) >>> distance = ad.physics.Distance(2.0) >>> print(distance) For some simple examples, you might also want to spot into the ad_rss_map_integration/python/tests folder.","title":"Map Integration"},{"location":"ad_rss_map_integration/ad_rss_map_integration_python/#usage-of-python-binding","text":"To use the compiled python binding, one has to extend the current environment to be able to use the newly created library. Afterwards, one can import the python package and use it as any other python module. ad-rss-lib$> echo \"Setting PYTHONPATH and LD_LIBRARY_PATH:\" ad-rss-lib$> source install/setup.bash ad-rss-lib$> python3.8 >>> import ad_rss_map_integration as ad >>> scene_creation = ad.rss.map.RssSceneCreation(1, ad.rss.world.RssDynamics()) >>> world_model = scene_creation.getWorldModel() >>> print(world_model) Also the interface of the dependencies can be accessed directly, since ad_rss_map_integration is relying on those (e.g. the type of the above returned world_model is actually ad.rss.world.WorldModel() provided by ad_rss): >>> ad.map.access.init(\"ad_rss_map_integration/python/tests/resources/Town01.txt\") >>> lanes = ad.map.lane.getLanes() >>> print(len(lanes)) >>> distance = ad.physics.Distance(2.0) >>> print(distance) For some simple examples, you might also want to spot into the ad_rss_map_integration/python/tests folder.","title":"Usage of python binding"}]}